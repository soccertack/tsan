!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ATOMIC	rtl/tsan_interface_atomic.cc	874;"	d	file:
ATOMIC_RET	rtl/tsan_interface_atomic.cc	884;"	d	file:
Access	rtl/tsan_report.cc	/^  const char *Access()     { return Blue(); }$/;"	f	class:__tsan::Decorator
Access	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Access(void *addr, bool is_write,$/;"	f	class:ScopedThread
Acquire	rtl/tsan_rtl_mutex.cc	/^void Acquire(ThreadState *thr, uptr pc, uptr addr) {$/;"	f	namespace:__tsan
AcquireGlobal	rtl/tsan_rtl_mutex.cc	/^void AcquireGlobal(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
AcquireImpl	rtl/tsan_rtl_mutex.cc	/^void AcquireImpl(ThreadState *thr, uptr pc, SyncClock *c) {$/;"	f	namespace:__tsan
AcquireReleaseImpl	rtl/tsan_rtl_mutex.cc	/^void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {$/;"	f	namespace:__tsan
Add	rtl/tsan_ignoreset.cc	/^void IgnoreSet::Add(u32 stack_id) {$/;"	f	class:__tsan::IgnoreSet
Add	rtl/tsan_mutexset.cc	/^void MutexSet::Add(u64 id, bool write, u64 epoch) {$/;"	f	class:__tsan::MutexSet
Add	rtl/tsan_mutexset.h	/^void MutexSet::Add(u64 id, bool write, u64 epoch) {}$/;"	f	class:__tsan::MutexSet
AddAllocCounter	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddAllocCounter(uptr alloc_counter) {$/;"	f	class:__tsan::ScopedReport
AddDeadMutex	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddDeadMutex(u64 id) {$/;"	f	class:__tsan::ScopedReport
AddExpectRace	rtl/tsan_interface_ann.cc	/^static void AddExpectRace(ExpectRace *list,$/;"	f	namespace:__tsan
AddLocation	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddLocation(uptr addr, uptr size) {$/;"	f	class:__tsan::ScopedReport
AddMemoryAccess	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddMemoryAccess(uptr addr, Shadow s, StackTrace stack,$/;"	f	class:__tsan::ScopedReport
AddMutex	rtl/tsan_rtl_report.cc	/^u64 ScopedReport::AddMutex(u64 id) {$/;"	f	class:__tsan::ScopedReport
AddMutex	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddMutex(const SyncVar *s) {$/;"	f	class:__tsan::ScopedReport
AddRacyStacks	rtl/tsan_rtl_report.cc	/^static void AddRacyStacks(ThreadState *thr, VarSizeStackTrace traces[2],$/;"	f	namespace:__tsan
AddSleep	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddSleep(u32 stack_id) {$/;"	f	class:__tsan::ScopedReport
AddStack	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddStack(StackTrace stack, bool suppressable) {$/;"	f	class:__tsan::ScopedReport
AddThread	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddThread(const ThreadContext *tctx, bool suppressable) {$/;"	f	class:__tsan::ScopedReport
AddThread	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddThread(int unique_tid, bool suppressable) {$/;"	f	class:__tsan::ScopedReport
AddUniqueTid	rtl/tsan_rtl_report.cc	/^void ScopedReport::AddUniqueTid(int unique_tid) {$/;"	f	class:__tsan::ScopedReport
Addr0AndSizeAreEqual	rtl/tsan_rtl.h	/^  bool Addr0AndSizeAreEqual(const Shadow s1, const Shadow s2) {$/;"	f	class:__tsan::Shadow
AfterSleep	rtl/tsan_rtl_mutex.cc	/^void AfterSleep(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
Alloc	rtl/tsan_dense_alloc.h	/^  IndexT Alloc(Cache *c) {$/;"	f	class:__tsan::DenseSlabAlloc
AllocBlock	rtl/tsan_sync.cc	/^void MetaMap::AllocBlock(ThreadState *thr, uptr pc, uptr p, uptr sz) {$/;"	f	class:__tsan::MetaMap
AllocGoroutine	go/tsan_go.cc	/^static ThreadState *AllocGoroutine() {$/;"	f	file:
Allocator	rtl/tsan_rtl.h	/^    SecondaryAllocator> Allocator;$/;"	t	namespace:__tsan
AllocatorCache	rtl/tsan_rtl.h	/^typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;$/;"	t	namespace:__tsan
AllocatorPrintStats	rtl/tsan_mman.cc	/^void AllocatorPrintStats() {$/;"	f	namespace:__tsan
AllocatorThreadFinish	rtl/tsan_mman.cc	/^void AllocatorThreadFinish(ThreadState *thr) {$/;"	f	namespace:__tsan
AllocatorThreadStart	rtl/tsan_mman.cc	/^void AllocatorThreadStart(ThreadState *thr) {$/;"	f	namespace:__tsan
AnnotateBenignRace	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateBenignRace($/;"	f
AnnotateBenignRaceSized	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateBenignRaceSized($/;"	f
AnnotateCondVarSignal	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateCondVarSignal(char *f, int l, uptr cv) {$/;"	f
AnnotateCondVarSignalAll	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateCondVarSignalAll(char *f, int l, uptr cv) {$/;"	f
AnnotateCondVarWait	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateCondVarWait(char *f, int l, uptr cv,$/;"	f
AnnotateEnableRaceDetection	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateEnableRaceDetection($/;"	f
AnnotateExpectRace	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateExpectRace($/;"	f
AnnotateFlushExpectedRaces	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateFlushExpectedRaces(char *f, int l) {$/;"	f
AnnotateFlushState	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateFlushState(char *f, int l) {$/;"	f
AnnotateHappensAfter	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateHappensAfter(char *f, int l, uptr addr) {$/;"	f
AnnotateHappensBefore	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateHappensBefore(char *f, int l, uptr addr) {$/;"	f
AnnotateIgnoreReadsBegin	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateIgnoreReadsBegin(char *f, int l) {$/;"	f
AnnotateIgnoreReadsEnd	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateIgnoreReadsEnd(char *f, int l) {$/;"	f
AnnotateIgnoreSyncBegin	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateIgnoreSyncBegin(char *f, int l) {$/;"	f
AnnotateIgnoreSyncEnd	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateIgnoreSyncEnd(char *f, int l) {$/;"	f
AnnotateIgnoreWritesBegin	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateIgnoreWritesBegin(char *f, int l) {$/;"	f
AnnotateIgnoreWritesEnd	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateIgnoreWritesEnd(char *f, int l) {$/;"	f
AnnotateMemoryIsInitialized	rtl/tsan_interface_ann.cc	/^AnnotateMemoryIsInitialized(char *f, int l, uptr mem, uptr sz) {}$/;"	f
AnnotateMemoryIsUninitialized	rtl/tsan_interface_ann.cc	/^AnnotateMemoryIsUninitialized(char *f, int l, uptr mem, uptr sz) {}$/;"	f
AnnotateMutexIsNotPHB	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateMutexIsNotPHB(char *f, int l, uptr mu) {$/;"	f
AnnotateMutexIsUsedAsCondVar	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateMutexIsUsedAsCondVar($/;"	f
AnnotateNewMemory	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateNewMemory(char *f, int l, uptr mem,$/;"	f
AnnotateNoOp	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateNoOp(char *f, int l, uptr mem) {$/;"	f
AnnotatePCQCreate	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotatePCQCreate($/;"	f
AnnotatePCQDestroy	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotatePCQDestroy($/;"	f
AnnotatePCQGet	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotatePCQGet($/;"	f
AnnotatePCQPut	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotatePCQPut($/;"	f
AnnotatePublishMemoryRange	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotatePublishMemoryRange($/;"	f
AnnotateRWLockAcquired	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateRWLockAcquired(char *f, int l, uptr m,$/;"	f
AnnotateRWLockCreate	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateRWLockCreate(char *f, int l, uptr m) {$/;"	f
AnnotateRWLockCreateStatic	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateRWLockCreateStatic(char *f, int l, uptr m) {$/;"	f
AnnotateRWLockDestroy	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateRWLockDestroy(char *f, int l, uptr m) {$/;"	f
AnnotateRWLockReleased	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateRWLockReleased(char *f, int l, uptr m,$/;"	f
AnnotateThreadName	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateThreadName($/;"	f
AnnotateTraceMemory	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateTraceMemory(char *f, int l, uptr mem) {$/;"	f
AnnotateUnpublishMemoryRange	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE AnnotateUnpublishMemoryRange($/;"	f
AsmSources	rtl/Makefile.mk	/^AsmSources := $(foreach file,$(wildcard $(Dir)\/*.S),$(notdir $(file)))$/;"	m
At	rtl/tsan_ignoreset.cc	/^u32 IgnoreSet::At(uptr i) const {$/;"	f	class:__tsan::IgnoreSet
AtExit	tests/rtl/tsan_test_util_linux.cc	/^static void AtExit() {$/;"	f	file:
AtExitCtx	rtl/tsan_interceptors.cc	/^struct AtExitCtx {$/;"	s	file:
AtomicCAS	rtl/tsan_interface_atomic.cc	/^static T AtomicCAS(ThreadState *thr, uptr pc,$/;"	f	file:
AtomicCAS	rtl/tsan_interface_atomic.cc	/^static bool AtomicCAS(ThreadState *thr, uptr pc,$/;"	f	file:
AtomicExchange	rtl/tsan_interface_atomic.cc	/^static T AtomicExchange(ThreadState *thr, uptr pc, volatile T *a, T v,$/;"	f	file:
AtomicFence	rtl/tsan_interface_atomic.cc	/^static void AtomicFence(ThreadState *thr, uptr pc, morder mo) {$/;"	f	file:
AtomicFetchAdd	rtl/tsan_interface_atomic.cc	/^static T AtomicFetchAdd(ThreadState *thr, uptr pc, volatile T *a, T v,$/;"	f	file:
AtomicFetchAnd	rtl/tsan_interface_atomic.cc	/^static T AtomicFetchAnd(ThreadState *thr, uptr pc, volatile T *a, T v,$/;"	f	file:
AtomicFetchNand	rtl/tsan_interface_atomic.cc	/^static T AtomicFetchNand(ThreadState *thr, uptr pc, volatile T *a, T v,$/;"	f	file:
AtomicFetchOr	rtl/tsan_interface_atomic.cc	/^static T AtomicFetchOr(ThreadState *thr, uptr pc, volatile T *a, T v,$/;"	f	file:
AtomicFetchSub	rtl/tsan_interface_atomic.cc	/^static T AtomicFetchSub(ThreadState *thr, uptr pc, volatile T *a, T v,$/;"	f	file:
AtomicFetchXor	rtl/tsan_interface_atomic.cc	/^static T AtomicFetchXor(ThreadState *thr, uptr pc, volatile T *a, T v,$/;"	f	file:
AtomicLoad	rtl/tsan_interface_atomic.cc	/^static T AtomicLoad(ThreadState *thr, uptr pc, const volatile T *a,$/;"	f	file:
AtomicRMW	rtl/tsan_interface_atomic.cc	/^static T AtomicRMW(ThreadState *thr, uptr pc, volatile T *a, T v, morder mo) {$/;"	f	file:
AtomicStatInc	rtl/tsan_interface_atomic.cc	/^static void AtomicStatInc(ThreadState *thr, uptr size, morder mo, StatType t) {$/;"	f	file:
AtomicStore	rtl/tsan_interface_atomic.cc	/^static void AtomicStore(ThreadState *thr, uptr pc, volatile T *a, T v,$/;"	f	file:
BLOCK_REAL	rtl/tsan_interceptors.cc	241;"	d	file:
BackgroundThread	rtl/tsan_rtl.cc	/^static void BackgroundThread(void *arg) {$/;"	f	namespace:__tsan
Backoff	rtl/tsan_mutex.cc	/^  Backoff()$/;"	f	class:__tsan::Backoff
Backoff	rtl/tsan_mutex.cc	/^class Backoff {$/;"	c	namespace:__tsan	file:
Backoff	tests/unit/tsan_mutex_test.cc	/^  void Backoff() {$/;"	f	class:__tsan::TestData
BeforeInitThread	tests/rtl/tsan_test_util_linux.cc	/^static void *BeforeInitThread(void *param) {$/;"	f	file:
Benchmark	tests/rtl/tsan_bench.cc	/^static void Benchmark() {$/;"	f	file:
BenignRaceImpl	rtl/tsan_interface_ann.cc	/^static void BenignRaceImpl($/;"	f	file:
BlockingCall	rtl/tsan_interceptors.cc	/^  explicit BlockingCall(ThreadState *thr)$/;"	f	struct:BlockingCall
BlockingCall	rtl/tsan_interceptors.cc	/^struct BlockingCall {$/;"	s	file:
CALL	tests/rtl/tsan_test_util_linux.cc	/^    CALL,$/;"	e	enum:Event::Type	file:
CALLERPC	rtl/tsan_interface.cc	19;"	d	file:
CALLERPC	rtl/tsan_interface_ann.cc	26;"	d	file:
CALLERPC	rtl/tsan_interface_inl.h	17;"	d
COMMON_INTERCEPTOR_BLOCK_REAL	rtl/tsan_interceptors.cc	2229;"	d	file:
COMMON_INTERCEPTOR_ENTER	rtl/tsan_interceptors.cc	2180;"	d	file:
COMMON_INTERCEPTOR_ENTER_NOIGNORE	rtl/tsan_interceptors.cc	2186;"	d	file:
COMMON_INTERCEPTOR_FD_ACCESS	rtl/tsan_interceptors.cc	2217;"	d	file:
COMMON_INTERCEPTOR_FD_ACQUIRE	rtl/tsan_interceptors.cc	2211;"	d	file:
COMMON_INTERCEPTOR_FD_RELEASE	rtl/tsan_interceptors.cc	2214;"	d	file:
COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT	rtl/tsan_interceptors.cc	2220;"	d	file:
COMMON_INTERCEPTOR_FILE_CLOSE	rtl/tsan_interceptors.cc	2199;"	d	file:
COMMON_INTERCEPTOR_FILE_OPEN	rtl/tsan_interceptors.cc	2192;"	d	file:
COMMON_INTERCEPTOR_HANDLE_RECVMSG	rtl/tsan_interceptors.cc	2246;"	d	file:
COMMON_INTERCEPTOR_LIBRARY_LOADED	rtl/tsan_interceptors.cc	2205;"	d	file:
COMMON_INTERCEPTOR_LIBRARY_UNLOADED	rtl/tsan_interceptors.cc	2208;"	d	file:
COMMON_INTERCEPTOR_MUTEX_LOCK	rtl/tsan_interceptors.cc	2234;"	d	file:
COMMON_INTERCEPTOR_MUTEX_REPAIR	rtl/tsan_interceptors.cc	2242;"	d	file:
COMMON_INTERCEPTOR_MUTEX_UNLOCK	rtl/tsan_interceptors.cc	2238;"	d	file:
COMMON_INTERCEPTOR_ON_EXIT	rtl/tsan_interceptors.cc	2231;"	d	file:
COMMON_INTERCEPTOR_READ_RANGE	rtl/tsan_interceptors.cc	2175;"	d	file:
COMMON_INTERCEPTOR_SET_PTHREAD_NAME	rtl/tsan_interceptors.cc	2226;"	d	file:
COMMON_INTERCEPTOR_SET_THREAD_NAME	rtl/tsan_interceptors.cc	2223;"	d	file:
COMMON_INTERCEPTOR_WRITE_RANGE	rtl/tsan_interceptors.cc	2170;"	d	file:
COMMON_INTERCEPT_FUNCTION	rtl/tsan_interceptors.cc	2168;"	d	file:
COMMON_SYSCALL_ACQUIRE	rtl/tsan_interceptors.cc	2344;"	d	file:
COMMON_SYSCALL_FD_ACQUIRE	rtl/tsan_interceptors.cc	2352;"	d	file:
COMMON_SYSCALL_FD_CLOSE	rtl/tsan_interceptors.cc	2350;"	d	file:
COMMON_SYSCALL_FD_RELEASE	rtl/tsan_interceptors.cc	2354;"	d	file:
COMMON_SYSCALL_POST_FORK	rtl/tsan_interceptors.cc	2359;"	d	file:
COMMON_SYSCALL_POST_READ_RANGE	rtl/tsan_interceptors.cc	2332;"	d	file:
COMMON_SYSCALL_POST_WRITE_RANGE	rtl/tsan_interceptors.cc	2338;"	d	file:
COMMON_SYSCALL_PRE_FORK	rtl/tsan_interceptors.cc	2356;"	d	file:
COMMON_SYSCALL_PRE_READ_RANGE	rtl/tsan_interceptors.cc	2326;"	d	file:
COMMON_SYSCALL_PRE_WRITE_RANGE	rtl/tsan_interceptors.cc	2329;"	d	file:
COMMON_SYSCALL_RELEASE	rtl/tsan_interceptors.cc	2347;"	d	file:
CPP_STAT_INC	rtl/tsan_clock.cc	86;"	d	file:
CPP_STAT_INC	rtl/tsan_clock.cc	88;"	d	file:
CPP_WEAK	rtl/tsan_defs.h	32;"	d
Cache	rtl/tsan_dense_alloc.h	/^  typedef DenseSlabAllocCache Cache;$/;"	t	class:__tsan::DenseSlabAlloc
Call	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Call(void(*pc)()) {$/;"	f	class:ScopedThread
CallUserSignalHandler	rtl/tsan_interceptors.cc	/^static void CallUserSignalHandler(ThreadState *thr, bool sync, bool acquire,$/;"	f	namespace:__tsan
Callback	dd/dd_rtl.cc	/^Callback::Callback(Thread *thr)$/;"	f	class:__dsan::Callback
Callback	dd/dd_rtl.h	/^struct Callback : DDCallback {$/;"	s	namespace:__dsan
Callback	rtl/tsan_rtl_mutex.cc	/^  Callback(ThreadState *thr, uptr pc)$/;"	f	struct:__tsan::Callback
Callback	rtl/tsan_rtl_mutex.cc	/^struct Callback : DDCallback {$/;"	s	namespace:__tsan	file:
CanLockAdj	rtl/tsan_mutex.cc	/^static bool CanLockAdj[MutexTypeCount][MutexTypeCount];$/;"	m	namespace:__tsan	file:
CanLockTab	rtl/tsan_mutex.cc	/^static MutexType CanLockTab[MutexTypeCount][MutexTypeCount] = {$/;"	m	namespace:__tsan	file:
CheckAndProtect	rtl/tsan_platform_linux.cc	/^static void CheckAndProtect() {$/;"	f	namespace:__tsan
CheckContains	rtl/tsan_interface_ann.cc	/^static bool CheckContains(ExpectRace *list, uptr addr, uptr size) {$/;"	f	namespace:__tsan
CheckId	rtl/tsan_sync.h	/^  bool CheckId(u64 uid) const {$/;"	f	struct:__tsan::SyncVar
CheckLocked	rtl/tsan_mutex.cc	/^void Mutex::CheckLocked() {$/;"	f	class:__tsan::Mutex
CheckNoLocks	rtl/tsan_mutex.cc	/^void CheckNoLocks(ThreadState *thr) {$/;"	f	namespace:__tsan
CheckNoLocks	rtl/tsan_mutex.cc	/^void InternalDeadlockDetector::CheckNoLocks() {$/;"	f	class:__tsan::InternalDeadlockDetector
CheckShadowMapping	rtl/tsan_rtl.cc	/^static void CheckShadowMapping() {$/;"	f	namespace:__tsan
ChooseSummaryStack	rtl/tsan_report.cc	/^static ReportStack *ChooseSummaryStack(const ReportDesc *rep) {$/;"	f	namespace:__tsan
ClassWithStatic	tests/rtl/tsan_mop.cc	/^struct ClassWithStatic {$/;"	s	file:
ClearHistorySize	rtl/tsan_rtl.h	/^  void ClearHistorySize() {$/;"	f	class:__tsan::FastState
ClearIgnoreBit	rtl/tsan_rtl.h	/^  void ClearIgnoreBit() { x_ &= ~kIgnoreBit; }$/;"	f	class:__tsan::FastState
ClockBlock	rtl/tsan_clock.h	/^  ClockBlock() {$/;"	f	struct:__tsan::ClockBlock
ClockBlock	rtl/tsan_clock.h	/^struct ClockBlock {$/;"	s	namespace:__tsan
ClockElem	rtl/tsan_clock.h	/^struct ClockElem {$/;"	s	namespace:__tsan
ClockFuzzer	tests/unit/tsan_clock_test.cc	/^static bool ClockFuzzer(bool printing) {$/;"	f	namespace:__tsan
CollectMatchedBenignRaces	rtl/tsan_interface_ann.cc	/^static void CollectMatchedBenignRaces(Vector<ExpectRace> *matched,$/;"	f	namespace:__tsan
CondContext	tests/rtl/tsan_posix.cc	/^struct CondContext {$/;"	s	file:
CondMutexUnlockCtx	rtl/tsan_interceptors.cc	/^struct CondMutexUnlockCtx {$/;"	s	file:
ContainsSameAccess	rtl/tsan_rtl.cc	/^bool ContainsSameAccess(u64 *s, u64 a, u64 sync_epoch, bool is_write) {$/;"	f	namespace:__tsan
ContainsSameAccessFast	rtl/tsan_rtl.cc	/^bool ContainsSameAccessFast(u64 *s, u64 a, u64 sync_epoch, bool is_write) {$/;"	f	namespace:__tsan
ContainsSameAccessSlow	rtl/tsan_rtl.cc	/^bool ContainsSameAccessSlow(u64 *s, u64 a, u64 sync_epoch, bool is_write) {$/;"	f	namespace:__tsan
Contention	rtl/tsan_mutex.cc	/^  u64 Contention() const {$/;"	f	class:__tsan::Backoff
Context	dd/dd_rtl.h	/^struct Context {$/;"	s	namespace:__dsan
Context	rtl/tsan_rtl.cc	/^Context::Context()$/;"	f	class:__tsan::Context
Context	rtl/tsan_rtl.h	/^struct Context {$/;"	s	namespace:__tsan
Create	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Create(const Mutex &m) {$/;"	f	class:ScopedThread
CreateThreadContext	rtl/tsan_rtl.cc	/^static ThreadContextBase *CreateThreadContext(u32 tid) {$/;"	f	namespace:__tsan
CurrentStackId	rtl/tsan_rtl.cc	/^u32 CurrentStackId(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
CurrentStackTrace	dd/dd_rtl.cc	/^static u32 CurrentStackTrace(Thread *thr, uptr skip) {$/;"	f	namespace:__dsan
DDMutexInit	rtl/tsan_rtl_mutex.cc	/^void DDMutexInit(ThreadState *thr, uptr pc, SyncVar *s) {$/;"	f	namespace:__tsan
DD_RTL_H	dd/dd_rtl.h	10;"	d
DPrintf	rtl/tsan_rtl.h	577;"	d
DPrintf	rtl/tsan_rtl.h	579;"	d
DPrintf2	rtl/tsan_rtl.h	583;"	d
DPrintf2	rtl/tsan_rtl.h	585;"	d
Data	tests/rtl/tsan_mop.cc	/^  static int Data[4];$/;"	m	struct:ClassWithStatic	file:
Data	tests/rtl/tsan_mop.cc	/^int ClassWithStatic::Data[4];$/;"	m	class:ClassWithStatic	file:
DebugDump	rtl/tsan_clock.cc	/^void SyncClock::DebugDump(int(*printf)(const char *s, ...)) {$/;"	f	class:__tsan::SyncClock
DebugDump	rtl/tsan_clock.cc	/^void ThreadClock::DebugDump(int(*printf)(const char *s, ...)) {$/;"	f	class:__tsan::ThreadClock
Decorator	rtl/tsan_report.cc	/^  Decorator() : SanitizerCommonDecorator() { }$/;"	f	class:__tsan::Decorator
Decorator	rtl/tsan_report.cc	/^class Decorator: public __sanitizer::SanitizerCommonDecorator {$/;"	c	namespace:__tsan	file:
Del	rtl/tsan_mutexset.cc	/^void MutexSet::Del(u64 id, bool write) {$/;"	f	class:__tsan::MutexSet
Del	rtl/tsan_mutexset.h	/^void MutexSet::Del(u64 id, bool write) {}$/;"	f	class:__tsan::MutexSet
DenseSlabAlloc	rtl/tsan_dense_alloc.h	/^  DenseSlabAlloc() {$/;"	f	class:__tsan::DenseSlabAlloc
DenseSlabAlloc	rtl/tsan_dense_alloc.h	/^class DenseSlabAlloc {$/;"	c	namespace:__tsan
DenseSlabAllocCache	rtl/tsan_dense_alloc.h	/^class DenseSlabAllocCache {$/;"	c	namespace:__tsan
Dependencies	Makefile.mk	/^Dependencies :=$/;"	m
Dependencies	rtl/Makefile.mk	/^Dependencies := $(wildcard $(Dir)\/*.h)$/;"	m
Desc	rtl/tsan_mutexset.h	/^  struct Desc {$/;"	s	class:__tsan::MutexSet
Destroy	tests/rtl/tsan_test_util_linux.cc	/^void Mutex::Destroy() {$/;"	f	class:Mutex
Destroy	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Destroy(const Mutex &m) {$/;"	f	class:ScopedThread
DestroyAndFree	rtl/tsan_mman.h	/^void DestroyAndFree(T *&p) {$/;"	f	namespace:__tsan
Detach	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Detach() {$/;"	f	class:ScopedThread
Dir2addr	rtl/tsan_fd.cc	/^uptr Dir2addr(const char *path) {$/;"	f	namespace:__tsan
Do	rtl/tsan_mutex.cc	/^  bool Do() {$/;"	f	class:__tsan::Backoff
DontNeedShadowFor	rtl/tsan_rtl.cc	/^void DontNeedShadowFor(uptr addr, uptr size) {$/;"	f	namespace:__tsan
Drain	rtl/tsan_dense_alloc.h	/^  void Drain(Cache *c) {$/;"	f	class:__tsan::DenseSlabAlloc
DynamicAnnContext	rtl/tsan_interface_ann.cc	/^  DynamicAnnContext()$/;"	f	struct:__tsan::DynamicAnnContext
DynamicAnnContext	rtl/tsan_interface_ann.cc	/^struct DynamicAnnContext {$/;"	s	namespace:__tsan	file:
EBUSY	rtl/tsan_interceptors.cc	/^const int EBUSY = 16;$/;"	v
EINVAL	rtl/tsan_interceptors.cc	/^const int EINVAL = 22;$/;"	v
EOWNERDEAD	rtl/tsan_interceptors.cc	/^const int EOWNERDEAD = 130;$/;"	v
EPOLL_CTL_ADD	rtl/tsan_interceptors.cc	/^const int EPOLL_CTL_ADD = 1;$/;"	v
EndAccess	rtl/tsan_report.cc	/^  const char *EndAccess()  { return Default(); }$/;"	f	class:__tsan::Decorator
EndLocation	rtl/tsan_report.cc	/^  const char *EndLocation() { return Default(); }$/;"	f	class:__tsan::Decorator
EndMutex	rtl/tsan_report.cc	/^  const char *EndMutex() { return Default(); }$/;"	f	class:__tsan::Decorator
EndSleep	rtl/tsan_report.cc	/^  const char *EndSleep() { return Default(); }$/;"	f	class:__tsan::Decorator
EndThreadDescription	rtl/tsan_report.cc	/^  const char *EndThreadDescription() { return Default(); }$/;"	f	class:__tsan::Decorator
EndWarning	rtl/tsan_report.cc	/^  const char *EndWarning() { return Default(); }$/;"	f	class:__tsan::Decorator
EnsureSize	rtl/tsan_vector.h	/^  void EnsureSize(uptr size) {$/;"	f	class:__tsan::Vector
EnterSymbolizer	rtl/tsan_symbolize.cc	/^void EnterSymbolizer() {$/;"	f	namespace:__tsan
Event	rtl/tsan_trace.h	/^typedef u64 Event;$/;"	t	namespace:__tsan
Event	tests/rtl/tsan_test_util_linux.cc	/^  Event(Type type, const void *ptr = 0, uptr arg = 0, uptr arg2 = 0)$/;"	f	struct:Event
Event	tests/rtl/tsan_test_util_linux.cc	/^struct Event {$/;"	s	file:
EventType	rtl/tsan_trace.h	/^enum EventType {$/;"	g	namespace:__tsan
EventTypeFuncEnter	rtl/tsan_trace.h	/^  EventTypeFuncEnter,$/;"	e	enum:__tsan::EventType
EventTypeFuncExit	rtl/tsan_trace.h	/^  EventTypeFuncExit,$/;"	e	enum:__tsan::EventType
EventTypeLock	rtl/tsan_trace.h	/^  EventTypeLock,$/;"	e	enum:__tsan::EventType
EventTypeMop	rtl/tsan_trace.h	/^  EventTypeMop,$/;"	e	enum:__tsan::EventType
EventTypeRLock	rtl/tsan_trace.h	/^  EventTypeRLock,$/;"	e	enum:__tsan::EventType
EventTypeRUnlock	rtl/tsan_trace.h	/^  EventTypeRUnlock$/;"	e	enum:__tsan::EventType
EventTypeUnlock	rtl/tsan_trace.h	/^  EventTypeUnlock,$/;"	e	enum:__tsan::EventType
ExitSymbolizer	rtl/tsan_symbolize.cc	/^void ExitSymbolizer() {$/;"	f	namespace:__tsan
Expect	tests/unit/tsan_mutexset_test.cc	/^static void Expect(const MutexSet &mset, uptr i, u64 id, bool write, u64 epoch,$/;"	f	namespace:__tsan
ExpectRace	rtl/tsan_interface_ann.cc	/^struct ExpectRace {$/;"	s	namespace:__tsan	file:
ExpectReport	tests/rtl/tsan_test_util_linux.cc	/^  void ExpectReport(ReportType type) {$/;"	f	struct:Event
ExtractRecvmsgFDs	rtl/tsan_platform_linux.cc	/^int ExtractRecvmsgFDs(void *msgp, int *fds, int nfd) {$/;"	f	namespace:__tsan
ExtractResolvFDs	rtl/tsan_platform_linux.cc	/^int ExtractResolvFDs(void *state, int *fds, int nfd) {$/;"	f	namespace:__tsan
F	rtl/tsan_md5.cc	17;"	d	file:
F_LOCK	rtl/tsan_interceptors.cc	100;"	d	file:
F_TEST	rtl/tsan_interceptors.cc	102;"	d	file:
F_TLOCK	rtl/tsan_interceptors.cc	101;"	d	file:
F_ULOCK	rtl/tsan_interceptors.cc	99;"	d	file:
FastState	rtl/tsan_rtl.h	/^  FastState(u64 tid, u64 epoch) {$/;"	f	class:__tsan::FastState
FastState	rtl/tsan_rtl.h	/^  explicit FastState(u64 x)$/;"	f	class:__tsan::FastState
FastState	rtl/tsan_rtl.h	/^class FastState {$/;"	c	namespace:__tsan
FdAccess	rtl/tsan_fd.cc	/^void FdAccess(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdAcquire	rtl/tsan_fd.cc	/^void FdAcquire(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdClose	rtl/tsan_fd.cc	/^void FdClose(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdContext	rtl/tsan_fd.cc	/^struct FdContext {$/;"	s	namespace:__tsan	file:
FdDesc	rtl/tsan_fd.cc	/^struct FdDesc {$/;"	s	namespace:__tsan	file:
FdDup	rtl/tsan_fd.cc	/^void FdDup(ThreadState *thr, uptr pc, int oldfd, int newfd) {$/;"	f	namespace:__tsan
FdEventCreate	rtl/tsan_fd.cc	/^void FdEventCreate(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdFileCreate	rtl/tsan_fd.cc	/^void FdFileCreate(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdInit	rtl/tsan_fd.cc	/^void FdInit() {$/;"	f	namespace:__tsan
FdInotifyCreate	rtl/tsan_fd.cc	/^void FdInotifyCreate(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdLocation	rtl/tsan_fd.cc	/^bool FdLocation(uptr addr, int *fd, int *tid, u32 *stack) {$/;"	f	namespace:__tsan
FdOnFork	rtl/tsan_fd.cc	/^void FdOnFork(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
FdPipeCreate	rtl/tsan_fd.cc	/^void FdPipeCreate(ThreadState *thr, uptr pc, int rfd, int wfd) {$/;"	f	namespace:__tsan
FdPollCreate	rtl/tsan_fd.cc	/^void FdPollCreate(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdRelease	rtl/tsan_fd.cc	/^void FdRelease(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdSignalCreate	rtl/tsan_fd.cc	/^void FdSignalCreate(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdSocketAccept	rtl/tsan_fd.cc	/^void FdSocketAccept(ThreadState *thr, uptr pc, int fd, int newfd) {$/;"	f	namespace:__tsan
FdSocketConnect	rtl/tsan_fd.cc	/^void FdSocketConnect(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdSocketConnecting	rtl/tsan_fd.cc	/^void FdSocketConnecting(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdSocketCreate	rtl/tsan_fd.cc	/^void FdSocketCreate(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
FdSync	rtl/tsan_fd.cc	/^struct FdSync {$/;"	s	namespace:__tsan	file:
File2addr	rtl/tsan_fd.cc	/^uptr File2addr(const char *path) {$/;"	f	namespace:__tsan
FillProfileCallback	rtl/tsan_platform_linux.cc	/^void FillProfileCallback(uptr p, uptr rss, bool file,$/;"	f	namespace:__tsan
Finalize	rtl/tsan_rtl.cc	/^int Finalize(ThreadState *thr) {$/;"	f	namespace:__tsan
FindRace	rtl/tsan_interface_ann.cc	/^static ExpectRace *FindRace(ExpectRace *list, uptr addr, uptr size) {$/;"	f	namespace:__tsan
FindThreadByTidLocked	rtl/tsan_rtl_report.cc	/^static ThreadContext *FindThreadByTidLocked(int tid) {$/;"	f	namespace:__tsan
FindThreadByUid	rtl/tsan_rtl_thread.cc	/^static bool FindThreadByUid(ThreadContextBase *tctx, void *arg) {$/;"	f	namespace:__tsan
FindThreadByUidLocked	rtl/tsan_rtl_report.cc	/^static ThreadContext *FindThreadByUidLocked(int unique_id) {$/;"	f	namespace:__tsan
FiredSuppression	rtl/tsan_rtl.h	/^struct FiredSuppression {$/;"	s	namespace:__tsan
Flags	dd/dd_rtl.h	/^struct Flags : CommonFlags, DDFlags {$/;"	s	namespace:__dsan
Flags	rtl/tsan_flags.h	/^struct Flags : DDFlags {$/;"	s	namespace:__tsan
FlushCache	rtl/tsan_dense_alloc.h	/^  void FlushCache(Cache *c) {$/;"	f	class:__tsan::DenseSlabAlloc
FlushShadowMemory	rtl/tsan_platform_linux.cc	/^void FlushShadowMemory() {$/;"	f	namespace:__tsan
FlushShadowMemory	rtl/tsan_platform_mac.cc	/^void FlushShadowMemory() {$/;"	f	namespace:__tsan
FlushShadowMemory	rtl/tsan_platform_windows.cc	/^void FlushShadowMemory() {$/;"	f	namespace:__tsan
FlushShadowMemoryCallback	rtl/tsan_platform_linux.cc	/^void FlushShadowMemoryCallback($/;"	f	namespace:__tsan
ForkBefore	rtl/tsan_rtl.cc	/^void ForkBefore(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
ForkChildAfter	rtl/tsan_rtl.cc	/^void ForkChildAfter(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
ForkParentAfter	rtl/tsan_rtl.cc	/^void ForkParentAfter(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
FrameIsInternal	rtl/tsan_rtl_report.cc	/^bool FrameIsInternal(const ReportStack *frame) {$/;"	f	namespace:__tsan
Free	rtl/tsan_dense_alloc.h	/^  void Free(Cache *c, IndexT idx) {$/;"	f	class:__tsan::DenseSlabAlloc
FreeBlock	rtl/tsan_sync.cc	/^uptr MetaMap::FreeBlock(ThreadState *thr, uptr pc, uptr p) {$/;"	f	class:__tsan::MetaMap
FreeRange	rtl/tsan_sync.cc	/^void MetaMap::FreeRange(ThreadState *thr, uptr pc, uptr p, uptr sz) {$/;"	f	class:__tsan::MetaMap
FuncEntry	rtl/tsan_rtl.cc	/^void FuncEntry(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
FuncExit	rtl/tsan_rtl.cc	/^void FuncExit(ThreadState *thr) {$/;"	f	namespace:__tsan
G	rtl/tsan_md5.cc	18;"	d	file:
GET	rtl/tsan_md5.cc	29;"	d	file:
GarbageThread	benchmarks/vts_many_threads_bench.cc	/^void* GarbageThread(void *unused) {$/;"	f
Get	rtl/tsan_mutexset.cc	/^MutexSet::Desc MutexSet::Get(uptr i) const {$/;"	f	class:__tsan::MutexSet
Get	rtl/tsan_mutexset.h	/^MutexSet::Desc MutexSet::Get(uptr i) const { return Desc(); }$/;"	f	class:__tsan::MutexSet
GetAndLock	rtl/tsan_sync.cc	/^SyncVar* MetaMap::GetAndLock(ThreadState *thr, uptr pc,$/;"	f	class:__tsan::MetaMap
GetBlock	rtl/tsan_sync.cc	/^MBlock* MetaMap::GetBlock(uptr p) {$/;"	f	class:__tsan::MetaMap
GetFreedAndReset	rtl/tsan_rtl.h	/^  bool GetFreedAndReset() {$/;"	f	class:__tsan::Shadow
GetHistorySize	rtl/tsan_rtl.h	/^  int GetHistorySize() const {$/;"	f	class:__tsan::FastState
GetId	rtl/tsan_sync.h	/^  u64 GetId() const {$/;"	f	struct:__tsan::SyncVar
GetIfExistsAndLock	rtl/tsan_sync.cc	/^SyncVar* MetaMap::GetIfExistsAndLock(uptr addr) {$/;"	f	class:__tsan::MetaMap
GetIgnoreBit	rtl/tsan_rtl.h	/^  bool GetIgnoreBit() const { return (s64)x_ < 0; }$/;"	f	class:__tsan::FastState
GetLsb	rtl/tsan_defs.h	/^T GetLsb(T v, int bits) {$/;"	f	namespace:__tsan
GetOrCreateAndLock	rtl/tsan_sync.cc	/^SyncVar* MetaMap::GetOrCreateAndLock(ThreadState *thr, uptr pc,$/;"	f	class:__tsan::MetaMap
GetRSS	rtl/tsan_platform_linux.cc	/^uptr GetRSS() {$/;"	f	namespace:__tsan
GetRSS	rtl/tsan_platform_mac.cc	/^uptr GetRSS() {$/;"	f	namespace:__tsan
GetRSS	rtl/tsan_platform_windows.cc	/^uptr GetRSS() {$/;"	f	namespace:__tsan
GetReport	rtl/tsan_rtl_report.cc	/^const ReportDesc *ScopedReport::GetReport() const {$/;"	f	class:__tsan::ScopedReport
GetShadowMemoryConsumption	rtl/tsan_platform_mac.cc	/^uptr GetShadowMemoryConsumption() {$/;"	f	namespace:__tsan
GetShadowMemoryConsumption	rtl/tsan_platform_windows.cc	/^uptr GetShadowMemoryConsumption() {$/;"	f	namespace:__tsan
GetThreadTrace	rtl/tsan_platform.h	/^uptr ALWAYS_INLINE GetThreadTrace(int tid) {$/;"	f	namespace:__tsan
GetThreadTraceHeader	rtl/tsan_platform.h	/^uptr ALWAYS_INLINE GetThreadTraceHeader(int tid) {$/;"	f	namespace:__tsan
GetTracePos	rtl/tsan_rtl.h	/^  u64 GetTracePos() const {$/;"	f	class:__tsan::FastState
GrowShadowStack	rtl/tsan_rtl.cc	/^void GrowShadowStack(ThreadState *thr) {$/;"	f	namespace:__tsan
H	rtl/tsan_md5.cc	19;"	d	file:
HACKY_CALL	rtl/tsan_rtl.h	695;"	d
HACKY_CALL	rtl/tsan_rtl.h	704;"	d
HandleEvent	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Impl::HandleEvent(Event *ev) {$/;"	f	class:ScopedThread::Impl
HandleRace	rtl/tsan_rtl.cc	/^void HandleRace(ThreadState *thr, u64 *shadow_mem,$/;"	f	namespace:__tsan
HandleRacyStacks	rtl/tsan_rtl_report.cc	/^static bool HandleRacyStacks(ThreadState *thr, VarSizeStackTrace traces[2],$/;"	f	namespace:__tsan
HandleRecvmsg	rtl/tsan_interceptors.cc	/^static void HandleRecvmsg(ThreadState *thr, uptr pc,$/;"	f	file:
HappensBefore	rtl/tsan_rtl.cc	/^static inline bool HappensBefore(Shadow old, ThreadState *thr) {$/;"	f	namespace:__tsan
I	rtl/tsan_md5.cc	20;"	d	file:
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(char*, realpath, const char *path, char *resolved_path) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_broadcast, pthread_cond_t *c) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_destroy, pthread_cond_t *c) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_init, pthread_cond_t *c,$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_signal, pthread_cond_t *c) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_timedwait, pthread_cond_t *c, pthread_mutex_t *m,$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_wait, pthread_cond_t *c, pthread_mutex_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_mutex_destroy, pthread_mutex_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_mutex_lock, pthread_mutex_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_mutex_trylock, pthread_mutex_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_mutex_unlock, pthread_mutex_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_rwlock_destroy, pthread_rwlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_rwlock_rdlock, pthread_rwlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_rwlock_timedrdlock, pthread_rwlock_t *m,$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_rwlock_timedwrlock, pthread_rwlock_t *m,$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_rwlock_tryrdlock, pthread_rwlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_rwlock_trywrlock, pthread_rwlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_rwlock_unlock, pthread_rwlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_rwlock_wrlock, pthread_rwlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_spin_destroy, pthread_spinlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_spin_lock, pthread_spinlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_spin_trylock, pthread_spinlock_t *m) {$/;"	f
INTERCEPTOR	dd/dd_interceptors.cc	/^INTERCEPTOR(int, pthread_spin_unlock, pthread_spinlock_t *m) {$/;"	f
INTERCEPTOR	rtl/tsan_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_broadcast, void *c) {$/;"	f
INTERCEPTOR	rtl/tsan_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_destroy, void *c) {$/;"	f
INTERCEPTOR	rtl/tsan_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_init, void *c, void *a) {$/;"	f
INTERCEPTOR	rtl/tsan_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_signal, void *c) {$/;"	f
INTERCEPTOR	rtl/tsan_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_timedwait, void *c, void *m, void *abstime) {$/;"	f
INTERCEPTOR	rtl/tsan_interceptors.cc	/^INTERCEPTOR(int, pthread_cond_wait, void *c, void *m) {$/;"	f
INTERFACE_ATTRIBUTE	rtl/tsan_interface_java.h	28;"	d
INTERFACE_ATTRIBUTE	rtl/tsan_interface_java.h	86;"	d
IgnoreSet	rtl/tsan_ignoreset.cc	/^IgnoreSet::IgnoreSet()$/;"	f	class:__tsan::IgnoreSet
IgnoreSet	rtl/tsan_ignoreset.h	/^class IgnoreSet {$/;"	c	namespace:__tsan
Impl	tests/rtl/tsan_test_util_linux.cc	/^struct ScopedThread::Impl {$/;"	s	class:ScopedThread	file:
Implementation	Makefile.mk	/^Implementation := Generic$/;"	m
Implementation	rtl/Makefile.mk	/^Implementation := Generic$/;"	m
IncrementEpoch	rtl/tsan_rtl.h	/^  void IncrementEpoch() {$/;"	f	class:__tsan::FastState
IndexT	rtl/tsan_dense_alloc.h	/^  typedef typename Cache::IndexT IndexT;$/;"	t	class:__tsan::DenseSlabAlloc
IndexT	rtl/tsan_dense_alloc.h	/^  typedef u32 IndexT;$/;"	t	class:__tsan::DenseSlabAllocCache
Init	rtl/tsan_stack_trace.cc	/^void VarSizeStackTrace::Init(const uptr *pcs, uptr cnt, uptr extra_top_pc) {$/;"	f	class:__tsan::VarSizeStackTrace
Init	rtl/tsan_sync.cc	/^void SyncVar::Init(ThreadState *thr, uptr pc, uptr addr, u64 uid) {$/;"	f	class:__tsan::SyncVar
Init	tests/rtl/tsan_test_util_linux.cc	/^void Mutex::Init() {$/;"	f	class:Mutex
InitCache	rtl/tsan_dense_alloc.h	/^  void InitCache(Cache *c) {$/;"	f	class:__tsan::DenseSlabAlloc
InitDataSeg	dd/dd_interceptors.cc	/^static void InitDataSeg() {$/;"	f	namespace:__dsan
InitDataSeg	rtl/tsan_platform_linux.cc	/^static void InitDataSeg() {$/;"	f	namespace:__tsan
InitList	rtl/tsan_interface_ann.cc	/^static void InitList(ExpectRace *list) {$/;"	f	namespace:__tsan
InitThread	dd/dd_interceptors.cc	/^static bool InitThread() {$/;"	f	file:
Initialize	dd/dd_rtl.cc	/^void Initialize() {$/;"	f	namespace:__dsan
Initialize	rtl/tsan_rtl.cc	/^void Initialize(ThreadState *thr) {$/;"	f	namespace:__tsan
InitializeAllocator	rtl/tsan_mman.cc	/^void InitializeAllocator() {$/;"	f	namespace:__tsan
InitializeDynamicAnnotations	go/tsan_go.cc	/^void InitializeDynamicAnnotations() {$/;"	f	namespace:__tsan
InitializeDynamicAnnotations	rtl/tsan_interface_ann.cc	/^void InitializeDynamicAnnotations() {$/;"	f	namespace:__tsan
InitializeFlags	dd/dd_rtl.cc	/^void InitializeFlags(Flags *f, const char *env) {$/;"	f	namespace:__dsan
InitializeFlags	rtl/tsan_flags.cc	/^void InitializeFlags(Flags *f, const char *env) {$/;"	f	namespace:__tsan
InitializeInterceptors	dd/dd_interceptors.cc	/^void InitializeInterceptors() {$/;"	f	namespace:__dsan
InitializeInterceptors	go/tsan_go.cc	/^void InitializeInterceptors() {$/;"	f	namespace:__tsan
InitializeInterceptors	rtl/tsan_interceptors.cc	/^void InitializeInterceptors() {$/;"	f	namespace:__tsan
InitializeLibIgnore	rtl/tsan_interceptors.cc	/^void InitializeLibIgnore() {$/;"	f	namespace:__tsan
InitializeMutex	rtl/tsan_mutex.cc	/^void InitializeMutex() {$/;"	f	namespace:__tsan
InitializePlatform	rtl/tsan_platform_linux.cc	/^void InitializePlatform() {$/;"	f	namespace:__tsan
InitializePlatform	rtl/tsan_platform_mac.cc	/^void InitializePlatform() {$/;"	f	namespace:__tsan
InitializePlatform	rtl/tsan_platform_windows.cc	/^void InitializePlatform() {$/;"	f	namespace:__tsan
InitializeShadowMemory	rtl/tsan_platform_linux.cc	/^void InitializeShadowMemory() {$/;"	f	namespace:__tsan
InitializeShadowMemory	rtl/tsan_platform_mac.cc	/^void InitializeShadowMemory() {$/;"	f	namespace:__tsan
InitializeSuppressions	rtl/tsan_suppressions.cc	/^void InitializeSuppressions() {$/;"	f	namespace:__tsan
InternalDeadlockDetector	rtl/tsan_mutex.cc	/^InternalDeadlockDetector::InternalDeadlockDetector() {$/;"	f	class:__tsan::InternalDeadlockDetector
InternalDeadlockDetector	rtl/tsan_mutex.h	/^class InternalDeadlockDetector {$/;"	c	namespace:__tsan
IsAcqRelOrder	rtl/tsan_interface_atomic.cc	/^static bool IsAcqRelOrder(morder mo) {$/;"	f	file:
IsAcquireOrder	rtl/tsan_interface_atomic.cc	/^static bool IsAcquireOrder(morder mo) {$/;"	f	file:
IsAlreadyAcquired	rtl/tsan_clock.cc	/^bool ThreadClock::IsAlreadyAcquired(const SyncClock *src) const {$/;"	f	class:__tsan::ThreadClock
IsAppMem	rtl/tsan_platform.h	/^bool IsAppMem(uptr mem) {$/;"	f	namespace:__tsan
IsAtomic	rtl/tsan_rtl.h	/^  bool IsAtomic() const {$/;"	f	class:__tsan::Shadow
IsBothReadsOrAtomic	rtl/tsan_rtl.h	/^  bool ALWAYS_INLINE IsBothReadsOrAtomic(bool kIsWrite, bool kIsAtomic) const {$/;"	f	class:__tsan::Shadow
IsExpectedReport	go/tsan_go.cc	/^bool IsExpectedReport(uptr addr, uptr size) {$/;"	f	namespace:__tsan
IsExpectedReport	rtl/tsan_interface_ann.cc	/^bool IsExpectedReport(uptr addr, uptr size) {$/;"	f	namespace:__tsan
IsFiredSuppression	rtl/tsan_rtl_report.cc	/^bool IsFiredSuppression(Context *ctx, const ScopedReport &srep,$/;"	f	namespace:__tsan
IsFiredSuppression	rtl/tsan_rtl_report.cc	/^static bool IsFiredSuppression(Context *ctx,$/;"	f	namespace:__tsan
IsFreed	rtl/tsan_rtl.h	/^  bool IsFreed() const {$/;"	f	class:__tsan::Shadow
IsGlobalVar	rtl/tsan_platform_linux.cc	/^bool IsGlobalVar(uptr addr) {$/;"	f	namespace:__tsan
IsInStackOrTls	rtl/tsan_rtl_report.cc	/^static bool IsInStackOrTls(ThreadContextBase *tctx_base, void *arg) {$/;"	f	namespace:__tsan
IsLoadOrder	rtl/tsan_interface_atomic.cc	/^static bool IsLoadOrder(morder mo) {$/;"	f	file:
IsMetaMem	rtl/tsan_platform.h	/^bool IsMetaMem(uptr mem) {$/;"	f	namespace:__tsan
IsRWNotWeaker	rtl/tsan_rtl.h	/^  bool ALWAYS_INLINE IsRWNotWeaker(bool kIsWrite, bool kIsAtomic) const {$/;"	f	class:__tsan::Shadow
IsRWWeakerOrEqual	rtl/tsan_rtl.h	/^  bool ALWAYS_INLINE IsRWWeakerOrEqual(bool kIsWrite, bool kIsAtomic) const {$/;"	f	class:__tsan::Shadow
IsRead	rtl/tsan_rtl.h	/^  bool ALWAYS_INLINE IsRead() const { return x_ & kReadBit; }$/;"	f	class:__tsan::Shadow
IsReleaseOrder	rtl/tsan_interface_atomic.cc	/^static bool IsReleaseOrder(morder mo) {$/;"	f	file:
IsShadowMem	rtl/tsan_platform.h	/^bool IsShadowMem(uptr mem) {$/;"	f	namespace:__tsan
IsStoreOrder	rtl/tsan_interface_atomic.cc	/^static bool IsStoreOrder(morder mo) {$/;"	f	file:
IsSuppressed	rtl/tsan_suppressions.cc	/^uptr IsSuppressed(ReportType typ, const ReportLocation *loc, Suppression **sp) {$/;"	f	namespace:__tsan
IsSuppressed	rtl/tsan_suppressions.cc	/^uptr IsSuppressed(ReportType typ, const ReportStack *stack, Suppression **sp) {$/;"	f	namespace:__tsan
IsThreadStackOrTls	rtl/tsan_rtl_report.cc	/^ThreadContext *IsThreadStackOrTls(uptr addr, bool *is_stack) {$/;"	f	namespace:__tsan
IsWrite	rtl/tsan_rtl.h	/^  bool ALWAYS_INLINE IsWrite() const { return !IsRead(); }$/;"	f	class:__tsan::Shadow
IsZero	rtl/tsan_rtl.h	/^  bool IsZero() const {$/;"	f	class:__tsan::Shadow
JavaContext	rtl/tsan_interface_java.cc	/^  JavaContext(jptr heap_begin, jptr heap_size)$/;"	f	struct:__tsan::JavaContext
JavaContext	rtl/tsan_interface_java.cc	/^struct JavaContext {$/;"	s	namespace:__tsan	file:
JmpBuf	rtl/tsan_rtl.h	/^struct JmpBuf {$/;"	s	namespace:__tsan
JmpBufGarbageCollect	rtl/tsan_interceptors.cc	/^static void JmpBufGarbageCollect(ThreadState *thr, uptr sp) {$/;"	f	file:
LoadShadow	rtl/tsan_rtl.cc	/^Shadow LoadShadow(u64 *p) {$/;"	f	namespace:__tsan
Location	rtl/tsan_report.cc	/^  const char *Location()   { return Green(); }$/;"	f	class:__tsan::Decorator
Lock	benchmarks/vts_many_threads_bench.cc	/^  void Lock() { pthread_mutex_lock(&m_); }$/;"	f	class:Mutex
Lock	rtl/tsan_mutex.cc	/^void InternalDeadlockDetector::Lock(MutexType t) {$/;"	f	class:__tsan::InternalDeadlockDetector
Lock	rtl/tsan_mutex.cc	/^void Mutex::Lock() {$/;"	f	class:__tsan::Mutex
Lock	rtl/tsan_mutex.h	/^typedef GenericScopedLock<Mutex> Lock;$/;"	t	namespace:__tsan
Lock	tests/rtl/tsan_test_util_linux.cc	/^void Mutex::Lock() {$/;"	f	class:Mutex
Lock	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Lock(const Mutex &m) {$/;"	f	class:ScopedThread
Lock	tests/unit/tsan_mutex_test.cc	/^  typedef GenericScopedLock<MutexType> Lock;$/;"	t	class:__tsan::TestData	file:
LongJmp	rtl/tsan_interceptors.cc	/^static void LongJmp(ThreadState *thr, uptr *env) {$/;"	f	file:
MAP_FAILED	rtl/tsan_interceptors.cc	/^void *const MAP_FAILED = (void*)-1;$/;"	v
MAP_FIXED	rtl/tsan_interceptors.cc	/^const int MAP_FIXED = 0x10;$/;"	v
MBlock	rtl/tsan_defs.h	/^struct MBlock {$/;"	s	namespace:__tsan
MBlockAtExit	rtl/tsan_mman.h	/^  MBlockAtExit,$/;"	e	enum:__tsan::MBlockType
MBlockClock	rtl/tsan_mman.h	/^  MBlockClock,$/;"	e	enum:__tsan::MBlockType
MBlockDeadInfo	rtl/tsan_mman.h	/^  MBlockDeadInfo,$/;"	e	enum:__tsan::MBlockType
MBlockExpectRace	rtl/tsan_mman.h	/^  MBlockExpectRace,$/;"	e	enum:__tsan::MBlockType
MBlockFlag	rtl/tsan_mman.h	/^  MBlockFlag,$/;"	e	enum:__tsan::MBlockType
MBlockJmpBuf	rtl/tsan_mman.h	/^  MBlockJmpBuf,$/;"	e	enum:__tsan::MBlockType
MBlockRacyAddresses	rtl/tsan_mman.h	/^  MBlockRacyAddresses,$/;"	e	enum:__tsan::MBlockType
MBlockRacyStacks	rtl/tsan_mman.h	/^  MBlockRacyStacks,$/;"	e	enum:__tsan::MBlockType
MBlockReport	rtl/tsan_mman.h	/^  MBlockReport,$/;"	e	enum:__tsan::MBlockType
MBlockReportLoc	rtl/tsan_mman.h	/^  MBlockReportLoc,$/;"	e	enum:__tsan::MBlockType
MBlockReportMop	rtl/tsan_mman.h	/^  MBlockReportMop,$/;"	e	enum:__tsan::MBlockType
MBlockReportMutex	rtl/tsan_mman.h	/^  MBlockReportMutex,$/;"	e	enum:__tsan::MBlockType
MBlockReportStack	rtl/tsan_mman.h	/^  MBlockReportStack,$/;"	e	enum:__tsan::MBlockType
MBlockReportThread	rtl/tsan_mman.h	/^  MBlockReportThread,$/;"	e	enum:__tsan::MBlockType
MBlockScopedBuf	rtl/tsan_mman.h	/^  MBlockScopedBuf,$/;"	e	enum:__tsan::MBlockType
MBlockShadowStack	rtl/tsan_mman.h	/^  MBlockShadowStack,$/;"	e	enum:__tsan::MBlockType
MBlockSignal	rtl/tsan_mman.h	/^  MBlockSignal,$/;"	e	enum:__tsan::MBlockType
MBlockStackTrace	rtl/tsan_mman.h	/^  MBlockStackTrace,$/;"	e	enum:__tsan::MBlockType
MBlockString	rtl/tsan_mman.h	/^  MBlockString,$/;"	e	enum:__tsan::MBlockType
MBlockSuppression	rtl/tsan_mman.h	/^  MBlockSuppression,$/;"	e	enum:__tsan::MBlockType
MBlockSync	rtl/tsan_mman.h	/^  MBlockSync,$/;"	e	enum:__tsan::MBlockType
MBlockThreadContex	rtl/tsan_mman.h	/^  MBlockThreadContex,$/;"	e	enum:__tsan::MBlockType
MBlockType	rtl/tsan_mman.h	/^enum MBlockType {$/;"	g	namespace:__tsan
MBlockTypeCount	rtl/tsan_mman.h	/^  MBlockTypeCount$/;"	e	enum:__tsan::MBlockType
MD5Hash	rtl/tsan_defs.h	/^struct MD5Hash {$/;"	s	namespace:__tsan
MD5_CTX	rtl/tsan_md5.cc	/^} MD5_CTX;$/;"	t	namespace:__tsan	typeref:struct:__tsan::__anon5	file:
MD5_Final	rtl/tsan_md5.cc	/^void MD5_Final(unsigned char *result, MD5_CTX *ctx) {$/;"	f	namespace:__tsan
MD5_Init	rtl/tsan_md5.cc	/^void MD5_Init(MD5_CTX *ctx) {$/;"	f	namespace:__tsan
MD5_Update	rtl/tsan_md5.cc	/^void MD5_Update(MD5_CTX *ctx, const void *data, ulong_t size) {$/;"	f	namespace:__tsan
MD5_u32plus	rtl/tsan_md5.cc	/^typedef unsigned int MD5_u32plus;$/;"	t	namespace:__tsan	file:
MEMCPY	tests/rtl/tsan_test_util_linux.cc	/^    MEMCPY,$/;"	e	enum:Event::Type	file:
MEMSET	tests/rtl/tsan_test_util_linux.cc	/^    MEMSET$/;"	e	enum:Event::Type	file:
MUTEX_CREATE	tests/rtl/tsan_test_util_linux.cc	/^    MUTEX_CREATE,$/;"	e	enum:Event::Type	file:
MUTEX_DESTROY	tests/rtl/tsan_test_util_linux.cc	/^    MUTEX_DESTROY,$/;"	e	enum:Event::Type	file:
MUTEX_LOCK	tests/rtl/tsan_test_util_linux.cc	/^    MUTEX_LOCK,$/;"	e	enum:Event::Type	file:
MUTEX_READLOCK	tests/rtl/tsan_test_util_linux.cc	/^    MUTEX_READLOCK,$/;"	e	enum:Event::Type	file:
MUTEX_READUNLOCK	tests/rtl/tsan_test_util_linux.cc	/^    MUTEX_READUNLOCK,$/;"	e	enum:Event::Type	file:
MUTEX_TRYLOCK	tests/rtl/tsan_test_util_linux.cc	/^    MUTEX_TRYLOCK,$/;"	e	enum:Event::Type	file:
MUTEX_TRYREADLOCK	tests/rtl/tsan_test_util_linux.cc	/^    MUTEX_TRYREADLOCK,$/;"	e	enum:Event::Type	file:
MUTEX_UNLOCK	tests/rtl/tsan_test_util_linux.cc	/^    MUTEX_UNLOCK,$/;"	e	enum:Event::Type	file:
MainThread	tests/rtl/tsan_test_util.h	/^  MainThread()$/;"	f	class:MainThread
MainThread	tests/rtl/tsan_test_util.h	/^class MainThread : public ScopedThread {$/;"	c
Map	rtl/tsan_dense_alloc.h	/^  T *Map(IndexT idx) {$/;"	f	class:__tsan::DenseSlabAlloc
MapRodata	rtl/tsan_platform_linux.cc	/^static void MapRodata() {$/;"	f	namespace:__tsan
MapShadow	rtl/tsan_rtl.cc	/^void MapShadow(uptr addr, uptr size) {$/;"	f	namespace:__tsan
MapThreadTrace	rtl/tsan_rtl.cc	/^void MapThreadTrace(uptr addr, uptr size) {$/;"	f	namespace:__tsan
MapUnmapCallback	rtl/tsan_mman.cc	/^struct MapUnmapCallback {$/;"	s	namespace:__tsan	file:
MarkAsFreed	rtl/tsan_rtl.h	/^  void MarkAsFreed() {$/;"	f	class:__tsan::Shadow
MaybeReportThreadLeak	rtl/tsan_rtl_thread.cc	/^static void MaybeReportThreadLeak(ThreadContextBase *tctx_base, void *arg) {$/;"	f	namespace:__tsan
MemCount	rtl/tsan_platform_linux.cc	/^  MemCount  = 8,$/;"	e	enum:__tsan::__anon4	file:
MemFile	rtl/tsan_platform_linux.cc	/^  MemFile   = 3,$/;"	e	enum:__tsan::__anon4	file:
MemHeap	rtl/tsan_platform_linux.cc	/^  MemHeap   = 6,$/;"	e	enum:__tsan::__anon4	file:
MemLoc	tests/rtl/tsan_test_util.h	/^  explicit MemLoc(void *const real_addr) : loc_(real_addr) { }$/;"	f	class:MemLoc
MemLoc	tests/rtl/tsan_test_util.h	/^class MemLoc {$/;"	c
MemLoc	tests/rtl/tsan_test_util_linux.cc	/^MemLoc::MemLoc(int offset_from_aligned)$/;"	f	class:MemLoc
MemMeta	rtl/tsan_platform_linux.cc	/^  MemMeta   = 2,$/;"	e	enum:__tsan::__anon4	file:
MemMmap	rtl/tsan_platform_linux.cc	/^  MemMmap   = 4,$/;"	e	enum:__tsan::__anon4	file:
MemOther	rtl/tsan_platform_linux.cc	/^  MemOther  = 7,$/;"	e	enum:__tsan::__anon4	file:
MemShadow	rtl/tsan_platform_linux.cc	/^  MemShadow = 1,$/;"	e	enum:__tsan::__anon4	file:
MemToMeta	rtl/tsan_platform.h	/^u32 *MemToMeta(uptr x) {$/;"	f	namespace:__tsan
MemToShadow	rtl/tsan_platform.h	/^uptr MemToShadow(uptr x) {$/;"	f	namespace:__tsan
MemTotal	rtl/tsan_platform_linux.cc	/^  MemTotal  = 0,$/;"	e	enum:__tsan::__anon4	file:
MemTrace	rtl/tsan_platform_linux.cc	/^  MemTrace  = 5,$/;"	e	enum:__tsan::__anon4	file:
Memcpy	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Memcpy(void *dst, const void *src, int size,$/;"	f	class:ScopedThread
MemoryAccess	rtl/tsan_rtl.cc	/^void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,$/;"	f	namespace:__tsan
MemoryAccessImpl	rtl/tsan_rtl.cc	/^void MemoryAccessImpl(ThreadState *thr, uptr addr,$/;"	f	namespace:__tsan
MemoryAccessImpl1	rtl/tsan_rtl.cc	/^void MemoryAccessImpl1(ThreadState *thr, uptr addr,$/;"	f	namespace:__tsan
MemoryAccessRange	rtl/tsan_rtl_thread.cc	/^void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,$/;"	f	namespace:__tsan
MemoryProfiler	rtl/tsan_rtl.cc	/^static void MemoryProfiler(Context *ctx, fd_t fd, int i) {$/;"	f	namespace:__tsan
MemoryRangeFreed	rtl/tsan_rtl.cc	/^void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size) {$/;"	f	namespace:__tsan
MemoryRangeImitateWrite	rtl/tsan_rtl.cc	/^void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size) {$/;"	f	namespace:__tsan
MemoryRangeSet	rtl/tsan_rtl.cc	/^static void MemoryRangeSet(ThreadState *thr, uptr pc, uptr addr, uptr size,$/;"	f	namespace:__tsan
MemoryRead	rtl/tsan_rtl.h	/^void ALWAYS_INLINE MemoryRead(ThreadState *thr, uptr pc,$/;"	f	namespace:__tsan
MemoryReadAtomic	rtl/tsan_rtl.h	/^void ALWAYS_INLINE MemoryReadAtomic(ThreadState *thr, uptr pc,$/;"	f	namespace:__tsan
MemoryResetRange	rtl/tsan_rtl.cc	/^void MemoryResetRange(ThreadState *thr, uptr pc, uptr addr, uptr size) {$/;"	f	namespace:__tsan
MemoryWrite	rtl/tsan_rtl.h	/^void ALWAYS_INLINE MemoryWrite(ThreadState *thr, uptr pc,$/;"	f	namespace:__tsan
MemoryWriteAtomic	rtl/tsan_rtl.h	/^void ALWAYS_INLINE MemoryWriteAtomic(ThreadState *thr, uptr pc,$/;"	f	namespace:__tsan
Memset	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Memset(void *dst, int val, int size,$/;"	f	class:ScopedThread
MetaMap	rtl/tsan_sync.cc	/^MetaMap::MetaMap() {$/;"	f	class:__tsan::MetaMap
MetaMap	rtl/tsan_sync.h	/^class MetaMap {$/;"	c	namespace:__tsan
ModuleName	Makefile.mk	/^ModuleName := tsan$/;"	m
ModuleName	rtl/Makefile.mk	/^ModuleName := tsan$/;"	m
MopDesc	rtl/tsan_report.cc	/^static const char *MopDesc(bool first, bool write, bool atomic) {$/;"	f	namespace:__tsan
MoveMemory	rtl/tsan_sync.cc	/^void MetaMap::MoveMemory(uptr src, uptr dst, uptr sz) {$/;"	f	class:__tsan::MetaMap
Mutex	benchmarks/vts_many_threads_bench.cc	/^  Mutex()  { pthread_mutex_init(&m_, NULL); }$/;"	f	class:Mutex
Mutex	benchmarks/vts_many_threads_bench.cc	/^class __attribute__((aligned(64))) Mutex {$/;"	c	file:
Mutex	dd/dd_rtl.h	/^struct Mutex {$/;"	s	namespace:__dsan
Mutex	rtl/tsan_mutex.cc	/^Mutex::Mutex(MutexType type, StatType stat_type) {$/;"	f	class:__tsan::Mutex
Mutex	rtl/tsan_mutex.h	/^class Mutex {$/;"	c	namespace:__tsan
Mutex	rtl/tsan_report.cc	/^  const char *Mutex()   { return Magenta(); }$/;"	f	class:__tsan::Decorator
Mutex	tests/rtl/tsan_test_util.h	/^class Mutex {$/;"	c
Mutex	tests/rtl/tsan_test_util_linux.cc	/^Mutex::Mutex(Type type)$/;"	f	class:Mutex
MutexAfterLock	dd/dd_rtl.cc	/^void MutexAfterLock(Thread *thr, uptr m, bool writelock, bool trylock) {$/;"	f	namespace:__dsan
MutexBeforeLock	dd/dd_rtl.cc	/^void MutexBeforeLock(Thread *thr, uptr m, bool writelock) {$/;"	f	namespace:__dsan
MutexBeforeUnlock	dd/dd_rtl.cc	/^void MutexBeforeUnlock(Thread *thr, uptr m, bool writelock) {$/;"	f	namespace:__dsan
MutexCreate	rtl/tsan_rtl_mutex.cc	/^void MutexCreate(ThreadState *thr, uptr pc, uptr addr,$/;"	f	namespace:__tsan
MutexDestroy	dd/dd_rtl.cc	/^void MutexDestroy(Thread *thr, uptr m) {$/;"	f	namespace:__dsan
MutexDestroy	rtl/tsan_rtl_mutex.cc	/^void MutexDestroy(ThreadState *thr, uptr pc, uptr addr) {$/;"	f	namespace:__tsan
MutexHashMap	dd/dd_rtl.h	/^typedef AddrHashMap<Mutex, 31051> MutexHashMap;$/;"	t	namespace:__dsan
MutexLock	rtl/tsan_rtl_mutex.cc	/^void MutexLock(ThreadState *thr, uptr pc, uptr addr, int rec, bool try_lock) {$/;"	f	namespace:__tsan
MutexReadLock	rtl/tsan_rtl_mutex.cc	/^void MutexReadLock(ThreadState *thr, uptr pc, uptr addr, bool trylock) {$/;"	f	namespace:__tsan
MutexReadOrWriteUnlock	rtl/tsan_rtl_mutex.cc	/^void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {$/;"	f	namespace:__tsan
MutexReadUnlock	rtl/tsan_rtl_mutex.cc	/^void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {$/;"	f	namespace:__tsan
MutexRepair	rtl/tsan_rtl_mutex.cc	/^void MutexRepair(ThreadState *thr, uptr pc, uptr addr) {$/;"	f	namespace:__tsan
MutexSet	rtl/tsan_mutexset.cc	/^MutexSet::MutexSet() {$/;"	f	class:__tsan::MutexSet
MutexSet	rtl/tsan_mutexset.h	/^MutexSet::MutexSet() {}$/;"	f	class:__tsan::MutexSet
MutexSet	rtl/tsan_mutexset.h	/^class MutexSet {$/;"	c	namespace:__tsan
MutexType	rtl/tsan_mutex.h	/^enum MutexType {$/;"	g	namespace:__tsan
MutexTypeAnnotations	rtl/tsan_mutex.h	/^  MutexTypeAnnotations,$/;"	e	enum:__tsan::MutexType
MutexTypeAtExit	rtl/tsan_mutex.h	/^  MutexTypeAtExit,$/;"	e	enum:__tsan::MutexType
MutexTypeCount	rtl/tsan_mutex.h	/^  MutexTypeCount$/;"	e	enum:__tsan::MutexType
MutexTypeDDetector	rtl/tsan_mutex.h	/^  MutexTypeDDetector,$/;"	e	enum:__tsan::MutexType
MutexTypeInvalid	rtl/tsan_mutex.h	/^  MutexTypeInvalid,$/;"	e	enum:__tsan::MutexType
MutexTypeJavaMBlock	rtl/tsan_mutex.h	/^  MutexTypeJavaMBlock,$/;"	e	enum:__tsan::MutexType
MutexTypeLeaf	rtl/tsan_mutex.cc	/^const MutexType MutexTypeLeaf = (MutexType)-1;$/;"	m	namespace:__tsan	file:
MutexTypeMBlock	rtl/tsan_mutex.h	/^  MutexTypeMBlock,$/;"	e	enum:__tsan::MutexType
MutexTypeReport	rtl/tsan_mutex.h	/^  MutexTypeReport,$/;"	e	enum:__tsan::MutexType
MutexTypeSlab	rtl/tsan_mutex.h	/^  MutexTypeSlab,$/;"	e	enum:__tsan::MutexType
MutexTypeSyncTab	rtl/tsan_mutex.h	/^  MutexTypeSyncTab,$/;"	e	enum:__tsan::MutexType
MutexTypeSyncVar	rtl/tsan_mutex.h	/^  MutexTypeSyncVar,$/;"	e	enum:__tsan::MutexType
MutexTypeThreads	rtl/tsan_mutex.h	/^  MutexTypeThreads,$/;"	e	enum:__tsan::MutexType
MutexTypeTrace	rtl/tsan_mutex.h	/^  MutexTypeTrace,$/;"	e	enum:__tsan::MutexType
MutexUnlock	rtl/tsan_rtl_mutex.cc	/^int MutexUnlock(ThreadState *thr, uptr pc, uptr addr, bool all) {$/;"	f	namespace:__tsan
New	rtl/tsan_report.cc	/^ReportLocation *ReportLocation::New(ReportLocationType type) {$/;"	f	class:__tsan::ReportLocation
New	rtl/tsan_report.cc	/^ReportStack *ReportStack::New(uptr addr) {$/;"	f	class:__tsan::ReportStack
NoTsanAtomicCAS	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicCAS(volatile T *a, T c, T v, morder mo, morder fmo) {$/;"	f	file:
NoTsanAtomicCAS	rtl/tsan_interface_atomic.cc	/^static bool NoTsanAtomicCAS(volatile T *a, T *c, T v, morder mo, morder fmo) {$/;"	f	file:
NoTsanAtomicCAS	rtl/tsan_interface_atomic.cc	/^static bool NoTsanAtomicCAS(volatile a128 *a, a128 *c, a128 v,$/;"	f	file:
NoTsanAtomicExchange	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicExchange(volatile T *a, T v, morder mo) {$/;"	f	file:
NoTsanAtomicFence	rtl/tsan_interface_atomic.cc	/^static void NoTsanAtomicFence(morder mo) {$/;"	f	file:
NoTsanAtomicFetchAdd	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicFetchAdd(volatile T *a, T v, morder mo) {$/;"	f	file:
NoTsanAtomicFetchAnd	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicFetchAnd(volatile T *a, T v, morder mo) {$/;"	f	file:
NoTsanAtomicFetchNand	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicFetchNand(volatile T *a, T v, morder mo) {$/;"	f	file:
NoTsanAtomicFetchOr	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicFetchOr(volatile T *a, T v, morder mo) {$/;"	f	file:
NoTsanAtomicFetchSub	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicFetchSub(volatile T *a, T v, morder mo) {$/;"	f	file:
NoTsanAtomicFetchXor	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicFetchXor(volatile T *a, T v, morder mo) {$/;"	f	file:
NoTsanAtomicLoad	rtl/tsan_interface_atomic.cc	/^static T NoTsanAtomicLoad(const volatile T *a, morder mo) {$/;"	f	file:
NoTsanAtomicLoad	rtl/tsan_interface_atomic.cc	/^static a128 NoTsanAtomicLoad(const volatile a128 *a, morder mo) {$/;"	f	file:
NoTsanAtomicStore	rtl/tsan_interface_atomic.cc	/^static void NoTsanAtomicStore(volatile T *a, T v, morder mo) {$/;"	f	file:
NoTsanAtomicStore	rtl/tsan_interface_atomic.cc	/^static void NoTsanAtomicStore(volatile a128 *a, a128 v, morder mo) {$/;"	f	file:
Normal	tests/rtl/tsan_test_util.h	/^  enum Type { Normal, Spin, RW };$/;"	e	enum:Mutex::Type
OPERATOR_DELETE_BODY	rtl/tsan_interceptors.cc	594;"	d	file:
OPERATOR_NEW_BODY	rtl/tsan_interceptors.cc	559;"	d	file:
ObjNames	Makefile.mk	/^ObjNames :=$/;"	m
ObjNames	rtl/Makefile.mk	/^ObjNames := $(Sources:%.cc=%.o) $(AsmSources:%.S=%.o)$/;"	m
ObtainCurrentStack	rtl/tsan_rtl.h	/^void ObtainCurrentStack(ThreadState *thr, uptr toppc, StackTraceTy *stack) {$/;"	f	namespace:__tsan
OnCreated	rtl/tsan_rtl_thread.cc	/^void ThreadContext::OnCreated(void *arg) {$/;"	f	class:__tsan::ThreadContext
OnCreatedArgs	rtl/tsan_rtl_thread.cc	/^struct OnCreatedArgs {$/;"	s	namespace:__tsan	file:
OnDead	rtl/tsan_rtl_thread.cc	/^void ThreadContext::OnDead() {$/;"	f	class:__tsan::ThreadContext
OnDetached	rtl/tsan_rtl_thread.cc	/^void ThreadContext::OnDetached(void *arg) {$/;"	f	class:__tsan::ThreadContext
OnExit	rtl/tsan_interceptors.cc	/^static int OnExit(ThreadState *thr) {$/;"	f	file:
OnFinalize	rtl/tsan_rtl.cc	/^bool WEAK OnFinalize(bool failed) {$/;"	f	namespace:__tsan
OnFinished	rtl/tsan_rtl_thread.cc	/^void ThreadContext::OnFinished() {$/;"	f	class:__tsan::ThreadContext
OnInitialize	rtl/tsan_rtl.cc	/^void WEAK OnInitialize() {}$/;"	f	namespace:__tsan
OnJoined	rtl/tsan_rtl_thread.cc	/^void ThreadContext::OnJoined(void *arg) {$/;"	f	class:__tsan::ThreadContext
OnMap	rtl/tsan_mman.cc	/^  void OnMap(uptr p, uptr size) const { }$/;"	f	struct:__tsan::MapUnmapCallback
OnReport	rtl/tsan_rtl_report.cc	/^bool WEAK OnReport(const ReportDesc *rep, bool suppressed) {$/;"	f	namespace:__tsan
OnReport	tests/rtl/tsan_test_util_linux.cc	/^bool OnReport(const ReportDesc *rep, bool suppressed) {$/;"	f	namespace:__tsan
OnReset	rtl/tsan_rtl_thread.cc	/^void ThreadContext::OnReset() {$/;"	f	class:__tsan::ThreadContext
OnStarted	rtl/tsan_rtl_thread.cc	/^void ThreadContext::OnStarted(void *arg) {$/;"	f	class:__tsan::ThreadContext
OnStartedArgs	rtl/tsan_rtl_thread.cc	/^struct OnStartedArgs {$/;"	s	namespace:__tsan	file:
OnThreadIdle	rtl/tsan_sync.cc	/^void MetaMap::OnThreadIdle(ThreadState *thr) {$/;"	f	class:__tsan::MetaMap
OnUnmap	rtl/tsan_mman.cc	/^  void OnUnmap(uptr p, uptr size) const {$/;"	f	struct:__tsan::MapUnmapCallback
OnUserAlloc	rtl/tsan_mman.cc	/^void OnUserAlloc(ThreadState *thr, uptr pc, uptr p, uptr sz, bool write) {$/;"	f	namespace:__tsan
OnUserFree	rtl/tsan_mman.cc	/^void OnUserFree(ThreadState *thr, uptr pc, uptr p, bool write) {$/;"	f	namespace:__tsan
OutputReport	rtl/tsan_rtl_report.cc	/^bool OutputReport(ThreadState *thr, const ScopedReport &srep) {$/;"	f	namespace:__tsan
PTHREAD_BARRIER_SERIAL_THREAD	rtl/tsan_interceptors.cc	/^const int PTHREAD_BARRIER_SERIAL_THREAD = -1;$/;"	v
PTHREAD_MUTEX_RECURSIVE	rtl/tsan_interceptors.cc	/^const int PTHREAD_MUTEX_RECURSIVE = 1;$/;"	v
PTHREAD_MUTEX_RECURSIVE_NP	rtl/tsan_interceptors.cc	/^const int PTHREAD_MUTEX_RECURSIVE_NP = 1;$/;"	v
ParseFlags	rtl/tsan_flags.cc	/^static void ParseFlags(Flags *f, const char *env) {$/;"	f	namespace:__tsan
PopBack	rtl/tsan_vector.h	/^  void PopBack() {$/;"	f	class:__tsan::Vector
PrimaryAllocator	rtl/tsan_rtl.h	/^    DefaultSizeClassMap, MapUnmapCallback> PrimaryAllocator;$/;"	t	namespace:__tsan
PrintCurrentStack	rtl/tsan_rtl_report.cc	/^void PrintCurrentStack(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
PrintCurrentStackSlow	rtl/tsan_rtl_report.cc	/^void PrintCurrentStackSlow(uptr pc) {$/;"	f	namespace:__tsan
PrintLocation	rtl/tsan_report.cc	/^static void PrintLocation(const ReportLocation *loc) {$/;"	f	namespace:__tsan
PrintMatchedBenignRaces	rtl/tsan_interface_ann.cc	/^void PrintMatchedBenignRaces() {$/;"	f	namespace:__tsan
PrintMatchedSuppressions	rtl/tsan_suppressions.cc	/^void PrintMatchedSuppressions() {$/;"	f	namespace:__tsan
PrintMop	rtl/tsan_report.cc	/^static void PrintMop(const ReportMop *mop, bool first) {$/;"	f	namespace:__tsan
PrintMutex	rtl/tsan_report.cc	/^static void PrintMutex(const ReportMutex *rm) {$/;"	f	namespace:__tsan
PrintMutexSet	rtl/tsan_report.cc	/^static void PrintMutexSet(Vector<ReportMopMutex> const& mset) {$/;"	f	namespace:__tsan
PrintMutexShort	rtl/tsan_report.cc	/^static void PrintMutexShort(const ReportMutex *rm, const char *after) {$/;"	f	namespace:__tsan
PrintMutexShortWithAddress	rtl/tsan_report.cc	/^static void PrintMutexShortWithAddress(const ReportMutex *rm,$/;"	f	namespace:__tsan
PrintReport	rtl/tsan_report.cc	/^void PrintReport(const ReportDesc *rep) {$/;"	f	namespace:__tsan
PrintRes	check_analyze.sh	/^PrintRes() {$/;"	f
PrintSleep	rtl/tsan_report.cc	/^static void PrintSleep(const ReportStack *s) {$/;"	f	namespace:__tsan
PrintStack	rtl/tsan_report.cc	/^void PrintStack(const ReportStack *ent) {$/;"	f	namespace:__tsan
PrintStackTrace	dd/dd_rtl.cc	/^static void PrintStackTrace(Thread *thr, u32 stk) {$/;"	f	namespace:__dsan
PrintThread	rtl/tsan_report.cc	/^static void PrintThread(const ReportThread *rt) {$/;"	f	namespace:__tsan
ProcessPendingSignals	rtl/tsan_interceptors.cc	/^void ProcessPendingSignals(ThreadState *thr) {$/;"	f	namespace:__tsan
ProtectRange	rtl/tsan_platform_linux.cc	/^static void ProtectRange(uptr beg, uptr end) {$/;"	f	namespace:__tsan
PushBack	rtl/tsan_vector.h	/^  T *PushBack() {$/;"	f	class:__tsan::Vector
PushBack	rtl/tsan_vector.h	/^  T *PushBack(const T& v) {$/;"	f	class:__tsan::Vector
READ	tests/rtl/tsan_test_util_linux.cc	/^    READ,$/;"	e	enum:Event::Type	file:
RETURN	tests/rtl/tsan_test_util_linux.cc	/^    RETURN,$/;"	e	enum:Event::Type	file:
RW	tests/rtl/tsan_test_util.h	/^  enum Type { Normal, Spin, RW };$/;"	e	enum:Mutex::Type
RaceBetweenAtomicAndFree	rtl/tsan_rtl_report.cc	/^static bool RaceBetweenAtomicAndFree(ThreadState *thr) {$/;"	f	namespace:__tsan
RacyAddress	rtl/tsan_rtl.h	/^struct RacyAddress {$/;"	s	namespace:__tsan
RacyStacks	rtl/tsan_rtl.h	/^struct RacyStacks {$/;"	s	namespace:__tsan
Read	tests/rtl/tsan_test_util.h	/^  void Read(const MemLoc &ml, int size, bool expect_race = false) {$/;"	f	class:ScopedThread
Read	tests/unit/tsan_mutex_test.cc	/^  void Read() {$/;"	f	class:__tsan::TestData
Read1	tests/rtl/tsan_test_util.h	/^  void Read1(const MemLoc &ml, bool expect_race = false) {$/;"	f	class:ScopedThread
Read2	tests/rtl/tsan_test_util.h	/^  void Read2(const MemLoc &ml, bool expect_race = false) {$/;"	f	class:ScopedThread
Read4	tests/rtl/tsan_test_util.h	/^  void Read4(const MemLoc &ml, bool expect_race = false) {$/;"	f	class:ScopedThread
Read8	tests/rtl/tsan_test_util.h	/^  void Read8(const MemLoc &ml, bool expect_race = false) {$/;"	f	class:ScopedThread
ReadLock	rtl/tsan_mutex.cc	/^void Mutex::ReadLock() {$/;"	f	class:__tsan::Mutex
ReadLock	rtl/tsan_mutex.h	/^typedef GenericScopedReadLock<Mutex> ReadLock;$/;"	t	namespace:__tsan
ReadLock	tests/rtl/tsan_test_util_linux.cc	/^void Mutex::ReadLock() {$/;"	f	class:Mutex
ReadLock	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::ReadLock(const Mutex &m) {$/;"	f	class:ScopedThread
ReadUnlock	rtl/tsan_mutex.cc	/^void Mutex::ReadUnlock() {$/;"	f	class:__tsan::Mutex
ReadUnlock	tests/rtl/tsan_test_util_linux.cc	/^void Mutex::ReadUnlock() {$/;"	f	class:Mutex
ReadUnlock	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::ReadUnlock(const Mutex &m) {$/;"	f	class:ScopedThread
Refill	rtl/tsan_dense_alloc.h	/^  void Refill(Cache *c) {$/;"	f	class:__tsan::DenseSlabAlloc
Release	rtl/tsan_rtl_mutex.cc	/^void Release(ThreadState *thr, uptr pc, uptr addr) {$/;"	f	namespace:__tsan
ReleaseImpl	rtl/tsan_rtl_mutex.cc	/^void ReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {$/;"	f	namespace:__tsan
ReleaseStore	rtl/tsan_clock.cc	/^void ThreadClock::ReleaseStore(ClockCache *c, SyncClock *dst) const {$/;"	f	class:__tsan::ThreadClock
ReleaseStore	rtl/tsan_rtl_mutex.cc	/^void ReleaseStore(ThreadState *thr, uptr pc, uptr addr) {$/;"	f	namespace:__tsan
ReleaseStore	tests/unit/tsan_clock_test.cc	/^  void ReleaseStore(SimpleSyncClock *dst) const {$/;"	f	struct:__tsan::SimpleThreadClock
ReleaseStoreImpl	rtl/tsan_rtl_mutex.cc	/^void ReleaseStoreImpl(ThreadState *thr, uptr pc, SyncClock *c) {$/;"	f	namespace:__tsan
Remove	rtl/tsan_mutexset.cc	/^void MutexSet::Remove(u64 id) {$/;"	f	class:__tsan::MutexSet
Remove	rtl/tsan_mutexset.h	/^void MutexSet::Remove(u64 id) {}$/;"	f	class:__tsan::MutexSet
RemovePos	rtl/tsan_mutexset.cc	/^void MutexSet::RemovePos(uptr i) {$/;"	f	class:__tsan::MutexSet
RemovePos	rtl/tsan_mutexset.h	/^void MutexSet::RemovePos(uptr i) {}$/;"	f	class:__tsan::MutexSet
ReportDeadlock	dd/dd_rtl.cc	/^static void ReportDeadlock(Thread *thr, DDReport *rep) {$/;"	f	namespace:__dsan
ReportDeadlock	rtl/tsan_rtl_mutex.cc	/^void ReportDeadlock(ThreadState *thr, uptr pc, DDReport *r) {$/;"	f	namespace:__tsan
ReportDesc	rtl/tsan_report.cc	/^ReportDesc::ReportDesc()$/;"	f	class:__tsan::ReportDesc
ReportDesc	rtl/tsan_report.h	/^class ReportDesc {$/;"	c	namespace:__tsan
ReportIgnoresEnabled	rtl/tsan_rtl_thread.cc	/^static void ReportIgnoresEnabled(ThreadContext *tctx, IgnoreSet *set) {$/;"	f	namespace:__tsan
ReportLocation	rtl/tsan_report.cc	/^ReportLocation::ReportLocation(ReportLocationType type)$/;"	f	class:__tsan::ReportLocation
ReportLocation	rtl/tsan_report.h	/^struct ReportLocation {$/;"	s	namespace:__tsan
ReportLocationFD	rtl/tsan_report.h	/^  ReportLocationFD$/;"	e	enum:__tsan::ReportLocationType
ReportLocationGlobal	rtl/tsan_report.h	/^  ReportLocationGlobal,$/;"	e	enum:__tsan::ReportLocationType
ReportLocationHeap	rtl/tsan_report.h	/^  ReportLocationHeap,$/;"	e	enum:__tsan::ReportLocationType
ReportLocationStack	rtl/tsan_report.h	/^  ReportLocationStack,$/;"	e	enum:__tsan::ReportLocationType
ReportLocationTLS	rtl/tsan_report.h	/^  ReportLocationTLS,$/;"	e	enum:__tsan::ReportLocationType
ReportLocationType	rtl/tsan_report.h	/^enum ReportLocationType {$/;"	g	namespace:__tsan
ReportMissedExpectedRace	rtl/tsan_interface_ann.cc	/^static void ReportMissedExpectedRace(ExpectRace *race) {$/;"	f	namespace:__tsan
ReportMop	rtl/tsan_report.cc	/^ReportMop::ReportMop()$/;"	f	class:__tsan::ReportMop
ReportMop	rtl/tsan_report.h	/^struct ReportMop {$/;"	s	namespace:__tsan
ReportMopMutex	rtl/tsan_report.h	/^struct ReportMopMutex {$/;"	s	namespace:__tsan
ReportMutex	rtl/tsan_report.h	/^struct ReportMutex {$/;"	s	namespace:__tsan
ReportMutexMisuse	rtl/tsan_rtl_mutex.cc	/^static void ReportMutexMisuse(ThreadState *thr, uptr pc, ReportType typ,$/;"	f	namespace:__tsan
ReportRace	rtl/tsan_rtl_report.cc	/^void ReportRace(ThreadState *thr) {$/;"	f	namespace:__tsan
ReportStack	rtl/tsan_report.cc	/^ReportStack::ReportStack() : next(nullptr), info(), suppressable(false) {}$/;"	f	class:__tsan::ReportStack
ReportStack	rtl/tsan_report.h	/^struct ReportStack {$/;"	s	namespace:__tsan
ReportThread	rtl/tsan_report.h	/^struct ReportThread {$/;"	s	namespace:__tsan
ReportType	rtl/tsan_report.h	/^enum ReportType {$/;"	g	namespace:__tsan
ReportTypeDeadlock	rtl/tsan_report.h	/^  ReportTypeDeadlock$/;"	e	enum:__tsan::ReportType
ReportTypeErrnoInSignal	rtl/tsan_report.h	/^  ReportTypeErrnoInSignal,$/;"	e	enum:__tsan::ReportType
ReportTypeMutexBadReadLock	rtl/tsan_report.h	/^  ReportTypeMutexBadReadLock,$/;"	e	enum:__tsan::ReportType
ReportTypeMutexBadReadUnlock	rtl/tsan_report.h	/^  ReportTypeMutexBadReadUnlock,$/;"	e	enum:__tsan::ReportType
ReportTypeMutexBadUnlock	rtl/tsan_report.h	/^  ReportTypeMutexBadUnlock,$/;"	e	enum:__tsan::ReportType
ReportTypeMutexDestroyLocked	rtl/tsan_report.h	/^  ReportTypeMutexDestroyLocked,$/;"	e	enum:__tsan::ReportType
ReportTypeMutexDoubleLock	rtl/tsan_report.h	/^  ReportTypeMutexDoubleLock,$/;"	e	enum:__tsan::ReportType
ReportTypeRace	rtl/tsan_report.h	/^  ReportTypeRace,$/;"	e	enum:__tsan::ReportType
ReportTypeSignalUnsafe	rtl/tsan_report.h	/^  ReportTypeSignalUnsafe,$/;"	e	enum:__tsan::ReportType
ReportTypeString	rtl/tsan_report.cc	/^static const char *ReportTypeString(ReportType typ) {$/;"	f	namespace:__tsan
ReportTypeThreadLeak	rtl/tsan_report.h	/^  ReportTypeThreadLeak,$/;"	e	enum:__tsan::ReportType
ReportTypeUseAfterFree	rtl/tsan_report.h	/^  ReportTypeUseAfterFree,$/;"	e	enum:__tsan::ReportType
ReportTypeVptrRace	rtl/tsan_report.h	/^  ReportTypeVptrRace,$/;"	e	enum:__tsan::ReportType
ReportTypeVptrUseAfterFree	rtl/tsan_report.h	/^  ReportTypeVptrUseAfterFree,$/;"	e	enum:__tsan::ReportType
Reset	rtl/tsan_clock.cc	/^void SyncClock::Reset(ClockCache *c) {$/;"	f	class:__tsan::SyncClock
Reset	rtl/tsan_ignoreset.cc	/^void IgnoreSet::Reset() {$/;"	f	class:__tsan::IgnoreSet
Reset	rtl/tsan_sync.cc	/^void SyncVar::Reset(ThreadState *thr) {$/;"	f	class:__tsan::SyncVar
Reset	rtl/tsan_vector.h	/^  void Reset() {$/;"	f	class:__tsan::Vector
Reset	tests/unit/tsan_clock_test.cc	/^  void Reset() {$/;"	f	struct:__tsan::SimpleSyncClock
Resize	rtl/tsan_clock.cc	/^void SyncClock::Resize(ClockCache *c, uptr nclk) {$/;"	f	class:__tsan::SyncClock
Resize	rtl/tsan_vector.h	/^  void Resize(uptr size) {$/;"	f	class:__tsan::Vector
ResizeBuffer	rtl/tsan_stack_trace.cc	/^void VarSizeStackTrace::ResizeBuffer(uptr new_size) {$/;"	f	class:__tsan::VarSizeStackTrace
RestoreStack	rtl/tsan_rtl_report.cc	/^void RestoreStack(int tid, const u64 epoch, VarSizeStackTrace *stk,$/;"	f	namespace:__tsan
Return	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Return() {$/;"	f	class:ScopedThread
RoundDown	rtl/tsan_defs.h	/^T RoundDown(T p, u64 align) {$/;"	f	namespace:__tsan
RoundUp	rtl/tsan_defs.h	/^T RoundUp(T p, u64 align) {$/;"	f	namespace:__tsan
Run	benchmarks/mini_bench_local.cc	/^void Run(int idx) {$/;"	f
Run	benchmarks/mini_bench_shared.cc	/^void Run(int idx) {$/;"	f
RunningOnValgrind	rtl/tsan_interface_ann.cc	/^int INTERFACE_ATTRIBUTE RunningOnValgrind() {$/;"	f
SANITIZER_INTERCEPT_FGETPWENT	rtl/tsan_interceptors.cc	2164;"	d	file:
SANITIZER_INTERCEPT_GETADDRINFO	rtl/tsan_interceptors.cc	2154;"	d	file:
SANITIZER_INTERCEPT_GETPWENT	rtl/tsan_interceptors.cc	2162;"	d	file:
SANITIZER_INTERCEPT_GETPWENT_R	rtl/tsan_interceptors.cc	2163;"	d	file:
SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS	rtl/tsan_interceptors.cc	2165;"	d	file:
SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS	rtl/tsan_interceptors.cc	2166;"	d	file:
SANITIZER_WEAK_ATTRIBUTE	rtl/tsan_symbolize.cc	/^                               SANITIZER_WEAK_ATTRIBUTE;$/;"	m	namespace:__tsan	file:
SA_SIGINFO	rtl/tsan_interceptors.cc	/^const int SA_SIGINFO = 4;$/;"	v
SCOPED_ANNOTATION	rtl/tsan_interface_ann.cc	49;"	d	file:
SCOPED_ATOMIC	rtl/tsan_interface_atomic.cc	475;"	d	file:
SCOPED_INTERCEPTOR_RAW	rtl/tsan_interceptors.cc	215;"	d	file:
SCOPED_JAVA_FUNC	rtl/tsan_interface_java.cc	61;"	d	file:
SCOPED_TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	223;"	d	file:
SET	rtl/tsan_md5.cc	27;"	d	file:
SHUF	rtl/tsan_rtl.cc	662;"	d	file:
SHUTDOWN	tests/rtl/tsan_test_util_linux.cc	/^    SHUTDOWN,$/;"	e	enum:Event::Type	file:
SIGABRT	rtl/tsan_interceptors.cc	/^const int SIGABRT = 6;$/;"	v
SIGBUS	rtl/tsan_interceptors.cc	/^const int SIGBUS = 7;$/;"	v
SIGFPE	rtl/tsan_interceptors.cc	/^const int SIGFPE = 8;$/;"	v
SIGILL	rtl/tsan_interceptors.cc	/^const int SIGILL = 4;$/;"	v
SIGPIPE	rtl/tsan_interceptors.cc	/^const int SIGPIPE = 13;$/;"	v
SIGSEGV	rtl/tsan_interceptors.cc	/^const int SIGSEGV = 11;$/;"	v
SIGSYS	rtl/tsan_interceptors.cc	/^const int SIGSYS = 31;$/;"	v
SIGTERM	rtl/tsan_interceptors.cc	/^const int SIGTERM = 15;$/;"	v
SIG_DFL	rtl/tsan_interceptors.cc	/^const sighandler_t SIG_DFL = (sighandler_t)0;$/;"	v
SIG_ERR	rtl/tsan_interceptors.cc	/^const sighandler_t SIG_ERR = (sighandler_t)-1;$/;"	v
SIG_IGN	rtl/tsan_interceptors.cc	/^const sighandler_t SIG_IGN = (sighandler_t)1;$/;"	v
SIG_SETMASK	rtl/tsan_interceptors.cc	/^const int SIG_SETMASK = 2;$/;"	v
STEP	rtl/tsan_md5.cc	22;"	d	file:
ScopedAnnotation	rtl/tsan_interface_ann.cc	/^  ScopedAnnotation(ThreadState *thr, const char *aname, const char *f, int l,$/;"	f	class:__tsan::ScopedAnnotation
ScopedAnnotation	rtl/tsan_interface_ann.cc	/^class ScopedAnnotation {$/;"	c	namespace:__tsan	file:
ScopedAtomic	rtl/tsan_interface_atomic.cc	/^  ScopedAtomic(ThreadState *thr, uptr pc, const volatile void *a,$/;"	f	class:ScopedAtomic
ScopedAtomic	rtl/tsan_interface_atomic.cc	/^class ScopedAtomic {$/;"	c	file:
ScopedIgnoreInterceptors	rtl/tsan_rtl.h	/^  ScopedIgnoreInterceptors() {$/;"	f	struct:__tsan::ScopedIgnoreInterceptors
ScopedIgnoreInterceptors	rtl/tsan_rtl.h	/^struct ScopedIgnoreInterceptors {$/;"	s	namespace:__tsan
ScopedInterceptor	rtl/tsan_interceptors.cc	/^ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,$/;"	f	class:ScopedInterceptor
ScopedInterceptor	rtl/tsan_interceptors.cc	/^class ScopedInterceptor {$/;"	c	file:
ScopedJavaFunc	rtl/tsan_interface_java.cc	/^  ScopedJavaFunc(ThreadState *thr, uptr pc)$/;"	f	class:__tsan::ScopedJavaFunc
ScopedJavaFunc	rtl/tsan_interface_java.cc	/^class ScopedJavaFunc {$/;"	c	namespace:__tsan	file:
ScopedReport	rtl/tsan_rtl.h	/^class ScopedReport {$/;"	c	namespace:__tsan
ScopedReport	rtl/tsan_rtl_report.cc	/^ScopedReport::ScopedReport(ReportType typ) {$/;"	f	class:__tsan::ScopedReport
ScopedSyscall	rtl/tsan_interceptors.cc	/^  explicit ScopedSyscall(ThreadState *thr)$/;"	f	struct:ScopedSyscall
ScopedSyscall	rtl/tsan_interceptors.cc	/^struct ScopedSyscall {$/;"	s	file:
ScopedThread	tests/rtl/tsan_test_util.h	/^class ScopedThread {$/;"	c
ScopedThread	tests/rtl/tsan_test_util_linux.cc	/^ScopedThread::ScopedThread(bool detached, bool main) {$/;"	f	class:ScopedThread
ScopedThreadCallback	tests/rtl/tsan_test_util_linux.cc	/^void *ScopedThread::Impl::ScopedThreadCallback(void *arg) {$/;"	f	class:ScopedThread::Impl
SecondaryAllocator	rtl/tsan_rtl.h	/^typedef LargeMmapAllocator<MapUnmapCallback> SecondaryAllocator;$/;"	t	namespace:__tsan
SetAddr0AndSizeLog	rtl/tsan_rtl.h	/^  void SetAddr0AndSizeLog(u64 addr0, unsigned kAccessSizeLog) {$/;"	f	class:__tsan::Shadow
SetAtomic	rtl/tsan_rtl.h	/^  void SetAtomic(bool kIsAtomic) {$/;"	f	class:__tsan::Shadow
SetCount	rtl/tsan_rtl_report.cc	/^void ScopedReport::SetCount(int count) {$/;"	f	class:__tsan::ScopedReport
SetHistorySize	rtl/tsan_rtl.h	/^  void SetHistorySize(int hs) {$/;"	f	class:__tsan::FastState
SetIgnoreBit	rtl/tsan_rtl.h	/^  void SetIgnoreBit() { x_ |= kIgnoreBit; }$/;"	f	class:__tsan::FastState
SetJmp	rtl/tsan_interceptors.cc	/^static void SetJmp(ThreadState *thr, uptr sp, uptr mangled_sp) {$/;"	f	file:
SetWrite	rtl/tsan_rtl.h	/^  void SetWrite(unsigned kAccessIsWrite) {$/;"	f	class:__tsan::Shadow
Shadow	rtl/tsan_rtl.h	/^  explicit Shadow(const FastState &s)$/;"	f	class:__tsan::Shadow
Shadow	rtl/tsan_rtl.h	/^  explicit Shadow(u64 x)$/;"	f	class:__tsan::Shadow
Shadow	rtl/tsan_rtl.h	/^class Shadow : public FastState {$/;"	c	namespace:__tsan
ShadowToMem	rtl/tsan_platform.h	/^uptr ShadowToMem(uptr s) {$/;"	f	namespace:__tsan
SigCtx	rtl/tsan_interceptors.cc	/^static SignalContext *SigCtx(ThreadState *thr) {$/;"	f	file:
SignalContext	rtl/tsan_interceptors.cc	/^struct SignalContext {$/;"	s	namespace:__tsan	file:
SignalDesc	rtl/tsan_interceptors.cc	/^struct SignalDesc {$/;"	s	namespace:__tsan	file:
SignalUnsafeCall	rtl/tsan_mman.cc	/^static void SignalUnsafeCall(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
SimpleSyncClock	tests/unit/tsan_clock_test.cc	/^  SimpleSyncClock() {$/;"	f	struct:__tsan::SimpleSyncClock
SimpleSyncClock	tests/unit/tsan_clock_test.cc	/^struct SimpleSyncClock {$/;"	s	namespace:__tsan	file:
SimpleThreadClock	tests/unit/tsan_clock_test.cc	/^  explicit SimpleThreadClock(unsigned tid) {$/;"	f	struct:__tsan::SimpleThreadClock
SimpleThreadClock	tests/unit/tsan_clock_test.cc	/^struct SimpleThreadClock {$/;"	s	namespace:__tsan	file:
Size	rtl/tsan_ignoreset.cc	/^uptr IgnoreSet::Size() const {$/;"	f	class:__tsan::IgnoreSet
Size	rtl/tsan_mutexset.cc	/^uptr MutexSet::Size() const {$/;"	f	class:__tsan::MutexSet
Size	rtl/tsan_mutexset.h	/^uptr MutexSet::Size() const { return 0; }$/;"	f	class:__tsan::MutexSet
Size	rtl/tsan_vector.h	/^  uptr Size() const {$/;"	f	class:__tsan::Vector
SizeLog	rtl/tsan_interface_atomic.cc	/^static int SizeLog() {$/;"	f	file:
SkipTsanInternalFrames	rtl/tsan_report.cc	/^ReportStack *SkipTsanInternalFrames(ReportStack *ent) {$/;"	f	namespace:__tsan
Sleep	rtl/tsan_report.cc	/^  const char *Sleep()   { return Yellow(); }$/;"	f	class:__tsan::Decorator
Sources	Makefile.mk	/^Sources :=$/;"	m
Sources	rtl/Makefile.mk	/^Sources := $(foreach file,$(wildcard $(Dir)\/*.cc),$(notdir $(file)))$/;"	m
Spin	tests/rtl/tsan_test_util.h	/^  enum Type { Normal, Spin, RW };$/;"	e	enum:Mutex::Type
SplitId	rtl/tsan_sync.h	/^  static uptr SplitId(u64 id, u64 *uid) {$/;"	f	struct:__tsan::SyncVar
StackStripMain	rtl/tsan_rtl_report.cc	/^static void StackStripMain(ReportStack *stack) {$/;"	f	namespace:__tsan
StartBackgroundThread	rtl/tsan_rtl.cc	/^static void StartBackgroundThread() {$/;"	f	namespace:__tsan
StatAggregate	rtl/tsan_stat.cc	/^void StatAggregate(u64 *dst, u64 *src) {$/;"	f	namespace:__tsan
StatAnnotateBenignRace	rtl/tsan_stat.h	/^  StatAnnotateBenignRace,$/;"	e	enum:__tsan::StatType
StatAnnotateBenignRaceSized	rtl/tsan_stat.h	/^  StatAnnotateBenignRaceSized,$/;"	e	enum:__tsan::StatType
StatAnnotateCondVarSignal	rtl/tsan_stat.h	/^  StatAnnotateCondVarSignal,$/;"	e	enum:__tsan::StatType
StatAnnotateCondVarSignalAll	rtl/tsan_stat.h	/^  StatAnnotateCondVarSignalAll,$/;"	e	enum:__tsan::StatType
StatAnnotateCondVarWait	rtl/tsan_stat.h	/^  StatAnnotateCondVarWait,$/;"	e	enum:__tsan::StatType
StatAnnotateEnableRaceDetection	rtl/tsan_stat.h	/^  StatAnnotateEnableRaceDetection,$/;"	e	enum:__tsan::StatType
StatAnnotateExpectRace	rtl/tsan_stat.h	/^  StatAnnotateExpectRace,$/;"	e	enum:__tsan::StatType
StatAnnotateFlushExpectedRaces	rtl/tsan_stat.h	/^  StatAnnotateFlushExpectedRaces,$/;"	e	enum:__tsan::StatType
StatAnnotateFlushState	rtl/tsan_stat.h	/^  StatAnnotateFlushState,$/;"	e	enum:__tsan::StatType
StatAnnotateHappensAfter	rtl/tsan_stat.h	/^  StatAnnotateHappensAfter,$/;"	e	enum:__tsan::StatType
StatAnnotateHappensBefore	rtl/tsan_stat.h	/^  StatAnnotateHappensBefore,$/;"	e	enum:__tsan::StatType
StatAnnotateIgnoreReadsBegin	rtl/tsan_stat.h	/^  StatAnnotateIgnoreReadsBegin,$/;"	e	enum:__tsan::StatType
StatAnnotateIgnoreReadsEnd	rtl/tsan_stat.h	/^  StatAnnotateIgnoreReadsEnd,$/;"	e	enum:__tsan::StatType
StatAnnotateIgnoreSyncBegin	rtl/tsan_stat.h	/^  StatAnnotateIgnoreSyncBegin,$/;"	e	enum:__tsan::StatType
StatAnnotateIgnoreSyncEnd	rtl/tsan_stat.h	/^  StatAnnotateIgnoreSyncEnd,$/;"	e	enum:__tsan::StatType
StatAnnotateIgnoreWritesBegin	rtl/tsan_stat.h	/^  StatAnnotateIgnoreWritesBegin,$/;"	e	enum:__tsan::StatType
StatAnnotateIgnoreWritesEnd	rtl/tsan_stat.h	/^  StatAnnotateIgnoreWritesEnd,$/;"	e	enum:__tsan::StatType
StatAnnotateMutexIsNotPHB	rtl/tsan_stat.h	/^  StatAnnotateMutexIsNotPHB,$/;"	e	enum:__tsan::StatType
StatAnnotateMutexIsUsedAsCondVar	rtl/tsan_stat.h	/^  StatAnnotateMutexIsUsedAsCondVar,$/;"	e	enum:__tsan::StatType
StatAnnotateNewMemory	rtl/tsan_stat.h	/^  StatAnnotateNewMemory,$/;"	e	enum:__tsan::StatType
StatAnnotateNoOp	rtl/tsan_stat.h	/^  StatAnnotateNoOp,$/;"	e	enum:__tsan::StatType
StatAnnotatePCQCreate	rtl/tsan_stat.h	/^  StatAnnotatePCQCreate,$/;"	e	enum:__tsan::StatType
StatAnnotatePCQDestroy	rtl/tsan_stat.h	/^  StatAnnotatePCQDestroy,$/;"	e	enum:__tsan::StatType
StatAnnotatePCQGet	rtl/tsan_stat.h	/^  StatAnnotatePCQGet,$/;"	e	enum:__tsan::StatType
StatAnnotatePCQPut	rtl/tsan_stat.h	/^  StatAnnotatePCQPut,$/;"	e	enum:__tsan::StatType
StatAnnotatePublishMemoryRange	rtl/tsan_stat.h	/^  StatAnnotatePublishMemoryRange,$/;"	e	enum:__tsan::StatType
StatAnnotateRWLockAcquired	rtl/tsan_stat.h	/^  StatAnnotateRWLockAcquired,$/;"	e	enum:__tsan::StatType
StatAnnotateRWLockCreate	rtl/tsan_stat.h	/^  StatAnnotateRWLockCreate,$/;"	e	enum:__tsan::StatType
StatAnnotateRWLockCreateStatic	rtl/tsan_stat.h	/^  StatAnnotateRWLockCreateStatic,$/;"	e	enum:__tsan::StatType
StatAnnotateRWLockDestroy	rtl/tsan_stat.h	/^  StatAnnotateRWLockDestroy,$/;"	e	enum:__tsan::StatType
StatAnnotateRWLockReleased	rtl/tsan_stat.h	/^  StatAnnotateRWLockReleased,$/;"	e	enum:__tsan::StatType
StatAnnotateThreadName	rtl/tsan_stat.h	/^  StatAnnotateThreadName,$/;"	e	enum:__tsan::StatType
StatAnnotateTraceMemory	rtl/tsan_stat.h	/^  StatAnnotateTraceMemory,$/;"	e	enum:__tsan::StatType
StatAnnotateUnpublishMemoryRange	rtl/tsan_stat.h	/^  StatAnnotateUnpublishMemoryRange,$/;"	e	enum:__tsan::StatType
StatAnnotation	rtl/tsan_stat.h	/^  StatAnnotation,$/;"	e	enum:__tsan::StatType
StatAtomic	rtl/tsan_stat.h	/^  StatAtomic,$/;"	e	enum:__tsan::StatType
StatAtomic1	rtl/tsan_stat.h	/^  StatAtomic1,$/;"	e	enum:__tsan::StatType
StatAtomic16	rtl/tsan_stat.h	/^  StatAtomic16,$/;"	e	enum:__tsan::StatType
StatAtomic2	rtl/tsan_stat.h	/^  StatAtomic2,$/;"	e	enum:__tsan::StatType
StatAtomic4	rtl/tsan_stat.h	/^  StatAtomic4,$/;"	e	enum:__tsan::StatType
StatAtomic8	rtl/tsan_stat.h	/^  StatAtomic8,$/;"	e	enum:__tsan::StatType
StatAtomicAcq_Rel	rtl/tsan_stat.h	/^  StatAtomicAcq_Rel,$/;"	e	enum:__tsan::StatType
StatAtomicAcquire	rtl/tsan_stat.h	/^  StatAtomicAcquire,$/;"	e	enum:__tsan::StatType
StatAtomicCAS	rtl/tsan_stat.h	/^  StatAtomicCAS,$/;"	e	enum:__tsan::StatType
StatAtomicConsume	rtl/tsan_stat.h	/^  StatAtomicConsume,$/;"	e	enum:__tsan::StatType
StatAtomicExchange	rtl/tsan_stat.h	/^  StatAtomicExchange,$/;"	e	enum:__tsan::StatType
StatAtomicFence	rtl/tsan_stat.h	/^  StatAtomicFence,$/;"	e	enum:__tsan::StatType
StatAtomicFetchAdd	rtl/tsan_stat.h	/^  StatAtomicFetchAdd,$/;"	e	enum:__tsan::StatType
StatAtomicFetchAnd	rtl/tsan_stat.h	/^  StatAtomicFetchAnd,$/;"	e	enum:__tsan::StatType
StatAtomicFetchNand	rtl/tsan_stat.h	/^  StatAtomicFetchNand,$/;"	e	enum:__tsan::StatType
StatAtomicFetchOr	rtl/tsan_stat.h	/^  StatAtomicFetchOr,$/;"	e	enum:__tsan::StatType
StatAtomicFetchSub	rtl/tsan_stat.h	/^  StatAtomicFetchSub,$/;"	e	enum:__tsan::StatType
StatAtomicFetchXor	rtl/tsan_stat.h	/^  StatAtomicFetchXor,$/;"	e	enum:__tsan::StatType
StatAtomicLoad	rtl/tsan_stat.h	/^  StatAtomicLoad,$/;"	e	enum:__tsan::StatType
StatAtomicRelaxed	rtl/tsan_stat.h	/^  StatAtomicRelaxed,$/;"	e	enum:__tsan::StatType
StatAtomicRelease	rtl/tsan_stat.h	/^  StatAtomicRelease,$/;"	e	enum:__tsan::StatType
StatAtomicSeq_Cst	rtl/tsan_stat.h	/^  StatAtomicSeq_Cst,$/;"	e	enum:__tsan::StatType
StatAtomicStore	rtl/tsan_stat.h	/^  StatAtomicStore,$/;"	e	enum:__tsan::StatType
StatClockAcquire	rtl/tsan_stat.h	/^  StatClockAcquire,$/;"	e	enum:__tsan::StatType
StatClockAcquireEmpty	rtl/tsan_stat.h	/^  StatClockAcquireEmpty,$/;"	e	enum:__tsan::StatType
StatClockAcquireFastRelease	rtl/tsan_stat.h	/^  StatClockAcquireFastRelease,$/;"	e	enum:__tsan::StatType
StatClockAcquireFull	rtl/tsan_stat.h	/^  StatClockAcquireFull,$/;"	e	enum:__tsan::StatType
StatClockAcquireLarge	rtl/tsan_stat.h	/^  StatClockAcquireLarge,$/;"	e	enum:__tsan::StatType
StatClockAcquireRelease	rtl/tsan_stat.h	/^  StatClockAcquireRelease,$/;"	e	enum:__tsan::StatType
StatClockAcquireRepeat	rtl/tsan_stat.h	/^  StatClockAcquireRepeat,$/;"	e	enum:__tsan::StatType
StatClockAcquiredSomething	rtl/tsan_stat.h	/^  StatClockAcquiredSomething,$/;"	e	enum:__tsan::StatType
StatClockRelease	rtl/tsan_stat.h	/^  StatClockRelease,$/;"	e	enum:__tsan::StatType
StatClockReleaseAcquired	rtl/tsan_stat.h	/^  StatClockReleaseAcquired,$/;"	e	enum:__tsan::StatType
StatClockReleaseClearTail	rtl/tsan_stat.h	/^  StatClockReleaseClearTail,$/;"	e	enum:__tsan::StatType
StatClockReleaseFast1	rtl/tsan_stat.h	/^  StatClockReleaseFast1,$/;"	e	enum:__tsan::StatType
StatClockReleaseFast2	rtl/tsan_stat.h	/^  StatClockReleaseFast2,$/;"	e	enum:__tsan::StatType
StatClockReleaseFull	rtl/tsan_stat.h	/^  StatClockReleaseFull,$/;"	e	enum:__tsan::StatType
StatClockReleaseResize	rtl/tsan_stat.h	/^  StatClockReleaseResize,$/;"	e	enum:__tsan::StatType
StatClockReleaseSlow	rtl/tsan_stat.h	/^  StatClockReleaseSlow,$/;"	e	enum:__tsan::StatType
StatClockStore	rtl/tsan_stat.h	/^  StatClockStore,$/;"	e	enum:__tsan::StatType
StatClockStoreFast	rtl/tsan_stat.h	/^  StatClockStoreFast,$/;"	e	enum:__tsan::StatType
StatClockStoreFull	rtl/tsan_stat.h	/^  StatClockStoreFull,$/;"	e	enum:__tsan::StatType
StatClockStoreResize	rtl/tsan_stat.h	/^  StatClockStoreResize,$/;"	e	enum:__tsan::StatType
StatClockStoreTail	rtl/tsan_stat.h	/^  StatClockStoreTail,$/;"	e	enum:__tsan::StatType
StatCnt	rtl/tsan_stat.h	/^  StatCnt$/;"	e	enum:__tsan::StatType
StatEvents	rtl/tsan_stat.h	/^  StatEvents,$/;"	e	enum:__tsan::StatType
StatFuncEnter	rtl/tsan_stat.h	/^  StatFuncEnter,$/;"	e	enum:__tsan::StatType
StatFuncExit	rtl/tsan_stat.h	/^  StatFuncExit,$/;"	e	enum:__tsan::StatType
StatInc	rtl/tsan_rtl.h	/^void ALWAYS_INLINE StatInc(ThreadState *thr, StatType typ, u64 n = 1) {$/;"	f	namespace:__tsan
StatMop	rtl/tsan_stat.h	/^  StatMop,$/;"	e	enum:__tsan::StatType
StatMop1	rtl/tsan_stat.h	/^  StatMop1,  \/\/ These must be consequtive.$/;"	e	enum:__tsan::StatType
StatMop2	rtl/tsan_stat.h	/^  StatMop2,$/;"	e	enum:__tsan::StatType
StatMop4	rtl/tsan_stat.h	/^  StatMop4,$/;"	e	enum:__tsan::StatType
StatMop8	rtl/tsan_stat.h	/^  StatMop8,$/;"	e	enum:__tsan::StatType
StatMopIgnored	rtl/tsan_stat.h	/^  StatMopIgnored,$/;"	e	enum:__tsan::StatType
StatMopRange	rtl/tsan_stat.h	/^  StatMopRange,$/;"	e	enum:__tsan::StatType
StatMopRangeRodata	rtl/tsan_stat.h	/^  StatMopRangeRodata,$/;"	e	enum:__tsan::StatType
StatMopRead	rtl/tsan_stat.h	/^  StatMopRead,$/;"	e	enum:__tsan::StatType
StatMopRodata	rtl/tsan_stat.h	/^  StatMopRodata,$/;"	e	enum:__tsan::StatType
StatMopSame	rtl/tsan_stat.h	/^  StatMopSame,$/;"	e	enum:__tsan::StatType
StatMopWrite	rtl/tsan_stat.h	/^  StatMopWrite,$/;"	e	enum:__tsan::StatType
StatMtxAnnotations	rtl/tsan_stat.h	/^  StatMtxAnnotations,$/;"	e	enum:__tsan::StatType
StatMtxAtExit	rtl/tsan_stat.h	/^  StatMtxAtExit,$/;"	e	enum:__tsan::StatType
StatMtxDeadlockDetector	rtl/tsan_stat.h	/^  StatMtxDeadlockDetector,$/;"	e	enum:__tsan::StatType
StatMtxFD	rtl/tsan_stat.h	/^  StatMtxFD,$/;"	e	enum:__tsan::StatType
StatMtxJavaMBlock	rtl/tsan_stat.h	/^  StatMtxJavaMBlock,$/;"	e	enum:__tsan::StatType
StatMtxMBlock	rtl/tsan_stat.h	/^  StatMtxMBlock,$/;"	e	enum:__tsan::StatType
StatMtxReport	rtl/tsan_stat.h	/^  StatMtxReport,$/;"	e	enum:__tsan::StatType
StatMtxSlab	rtl/tsan_stat.h	/^  StatMtxSlab,$/;"	e	enum:__tsan::StatType
StatMtxSyncTab	rtl/tsan_stat.h	/^  StatMtxSyncTab,$/;"	e	enum:__tsan::StatType
StatMtxSyncVar	rtl/tsan_stat.h	/^  StatMtxSyncVar,$/;"	e	enum:__tsan::StatType
StatMtxThreads	rtl/tsan_stat.h	/^  StatMtxThreads,$/;"	e	enum:__tsan::StatType
StatMtxTotal	rtl/tsan_stat.h	/^  StatMtxTotal,$/;"	e	enum:__tsan::StatType
StatMtxTrace	rtl/tsan_stat.h	/^  StatMtxTrace,$/;"	e	enum:__tsan::StatType
StatMutexCreate	rtl/tsan_stat.h	/^  StatMutexCreate,$/;"	e	enum:__tsan::StatType
StatMutexDestroy	rtl/tsan_stat.h	/^  StatMutexDestroy,$/;"	e	enum:__tsan::StatType
StatMutexLock	rtl/tsan_stat.h	/^  StatMutexLock,$/;"	e	enum:__tsan::StatType
StatMutexReadLock	rtl/tsan_stat.h	/^  StatMutexReadLock,$/;"	e	enum:__tsan::StatType
StatMutexReadUnlock	rtl/tsan_stat.h	/^  StatMutexReadUnlock,$/;"	e	enum:__tsan::StatType
StatMutexRecLock	rtl/tsan_stat.h	/^  StatMutexRecLock,$/;"	e	enum:__tsan::StatType
StatMutexRecUnlock	rtl/tsan_stat.h	/^  StatMutexRecUnlock,$/;"	e	enum:__tsan::StatType
StatMutexUnlock	rtl/tsan_stat.h	/^  StatMutexUnlock,$/;"	e	enum:__tsan::StatType
StatOutput	rtl/tsan_stat.cc	/^void StatOutput(u64 *stat) {$/;"	f	namespace:__tsan
StatSet	rtl/tsan_rtl.h	/^void ALWAYS_INLINE StatSet(ThreadState *thr, StatType typ, u64 n) {$/;"	f	namespace:__tsan
StatShadowAnotherThread	rtl/tsan_stat.h	/^  StatShadowAnotherThread,$/;"	e	enum:__tsan::StatType
StatShadowIntersect	rtl/tsan_stat.h	/^  StatShadowIntersect,$/;"	e	enum:__tsan::StatType
StatShadowNonZero	rtl/tsan_stat.h	/^  StatShadowNonZero,  \/\/ Derived.$/;"	e	enum:__tsan::StatType
StatShadowNotIntersect	rtl/tsan_stat.h	/^  StatShadowNotIntersect,$/;"	e	enum:__tsan::StatType
StatShadowProcessed	rtl/tsan_stat.h	/^  StatShadowProcessed,$/;"	e	enum:__tsan::StatType
StatShadowReplace	rtl/tsan_stat.h	/^  StatShadowReplace,$/;"	e	enum:__tsan::StatType
StatShadowSameSize	rtl/tsan_stat.h	/^  StatShadowSameSize,$/;"	e	enum:__tsan::StatType
StatShadowSameThread	rtl/tsan_stat.h	/^  StatShadowSameThread,$/;"	e	enum:__tsan::StatType
StatShadowZero	rtl/tsan_stat.h	/^  StatShadowZero,$/;"	e	enum:__tsan::StatType
StatSyncAcquire	rtl/tsan_stat.h	/^  StatSyncAcquire,$/;"	e	enum:__tsan::StatType
StatSyncCreated	rtl/tsan_stat.h	/^  StatSyncCreated,$/;"	e	enum:__tsan::StatType
StatSyncDestroyed	rtl/tsan_stat.h	/^  StatSyncDestroyed,$/;"	e	enum:__tsan::StatType
StatSyncRelease	rtl/tsan_stat.h	/^  StatSyncRelease,$/;"	e	enum:__tsan::StatType
StatThreadCreate	rtl/tsan_stat.h	/^  StatThreadCreate,$/;"	e	enum:__tsan::StatType
StatThreadFinish	rtl/tsan_stat.h	/^  StatThreadFinish,$/;"	e	enum:__tsan::StatType
StatThreadMaxAlive	rtl/tsan_stat.h	/^  StatThreadMaxAlive,$/;"	e	enum:__tsan::StatType
StatThreadMaxTid	rtl/tsan_stat.h	/^  StatThreadMaxTid,$/;"	e	enum:__tsan::StatType
StatThreadReuse	rtl/tsan_stat.h	/^  StatThreadReuse,$/;"	e	enum:__tsan::StatType
StatType	rtl/tsan_stat.h	/^enum StatType {$/;"	g	namespace:__tsan
StaticInit	tests/rtl/tsan_test_util_linux.cc	/^void Mutex::StaticInit() {$/;"	f	class:Mutex
StopBackgroundThread	rtl/tsan_rtl.cc	/^static void StopBackgroundThread() {$/;"	f	namespace:__tsan
StoreIfNotYetStored	rtl/tsan_rtl.cc	/^void StoreIfNotYetStored(u64 *sp, u64 *s) {$/;"	f	namespace:__tsan
StoreShadow	rtl/tsan_rtl.cc	/^void StoreShadow(u64 *sp, u64 s) {$/;"	f	namespace:__tsan
SubDirs	Makefile.mk	/^SubDirs := rtl$/;"	m
SubDirs	rtl/Makefile.mk	/^SubDirs :=$/;"	m
SymbolizeCode	go/tsan_go.cc	/^ReportStack *SymbolizeCode(uptr addr) {$/;"	f	namespace:__tsan
SymbolizeCode	rtl/tsan_symbolize.cc	/^ReportStack *SymbolizeCode(uptr addr) {$/;"	f	namespace:__tsan
SymbolizeContext	go/tsan_go.cc	/^struct SymbolizeContext {$/;"	s	namespace:__tsan	file:
SymbolizeData	go/tsan_go.cc	/^ReportLocation *SymbolizeData(uptr addr) {$/;"	f	namespace:__tsan
SymbolizeData	rtl/tsan_symbolize.cc	/^ReportLocation *SymbolizeData(uptr addr) {$/;"	f	namespace:__tsan
SymbolizeFlush	rtl/tsan_symbolize.cc	/^void SymbolizeFlush() {$/;"	f	namespace:__tsan
SymbolizeStack	rtl/tsan_rtl_report.cc	/^static ReportStack *SymbolizeStack(StackTrace trace) {$/;"	f	namespace:__tsan
SymbolizeStackId	rtl/tsan_rtl_report.cc	/^ReportStack *SymbolizeStackId(u32 stack_id) {$/;"	f	namespace:__tsan
SymbolizerPrepareForSandboxing	go/tsan_go.cc	/^void SymbolizerPrepareForSandboxing() {$/;"	f	namespace:__sanitizer
SyncClock	rtl/tsan_clock.cc	/^SyncClock::SyncClock()$/;"	f	class:__tsan::SyncClock
SyncVar	rtl/tsan_sync.cc	/^SyncVar::SyncVar()$/;"	f	class:__tsan::SyncVar
SyncVar	rtl/tsan_sync.h	/^struct SyncVar {$/;"	s	namespace:__tsan
T	tests/unit/tsan_mutex_test.cc	/^  typedef u64 T;$/;"	t	class:__tsan::TestData	file:
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, FuncCall) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop1) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop1Read) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop1Write) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop2) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop2Read) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop2Write) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop4) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop4Read) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop4Write) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop8) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop8Read) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, Mop8Write) {$/;"	f
TEST	tests/rtl/tsan_bench.cc	/^TEST(DISABLED_BENCH, MutexLocal) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, BenignRaceOnVptr) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, HarmfulRaceOnVptr) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, LockedWriteThenRead) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, NoRaceWithOffset) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, RaceWithDeadThread) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, RaceWithOffset) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, RaceWithOffset2) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, ReadReadNoRace) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, ReadWriteRace) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, ReportDeadThread) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, ReportRace) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, SimpleWrite) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, SimpleWriteWrite) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, WriteReadRace) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, WriteThenLockedRead) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, WriteThenRead) {$/;"	f
TEST	tests/rtl/tsan_mop.cc	/^TEST(ThreadSanitizer, WriteWriteRace) {$/;"	f
TEST	tests/rtl/tsan_mutex.cc	/^TEST(DISABLED_BENCH_ThreadSanitizer, Singleton) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_mutex.cc	/^TEST(DISABLED_BENCH_ThreadSanitizer, StopFlag) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_mutex.cc	/^TEST(ThreadSanitizer, BasicMutex) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_mutex.cc	/^TEST(ThreadSanitizer, BasicRwMutex) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_mutex.cc	/^TEST(ThreadSanitizer, BasicSpinMutex) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_mutex.cc	/^TEST(ThreadSanitizer, Mutex) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_mutex.cc	/^TEST(ThreadSanitizer, RwMutex) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_mutex.cc	/^TEST(ThreadSanitizer, SpinMutex) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_mutex.cc	/^TEST(ThreadSanitizer, StaticMutex) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_posix.cc	/^TEST(Posix, CondBasic) {$/;"	f
TEST	tests/rtl/tsan_posix.cc	/^TEST(Posix, ThreadLocalAccesses) {$/;"	f
TEST	tests/rtl/tsan_posix.cc	/^TEST(Posix, ThreadSpecificDtors) {$/;"	f
TEST	tests/rtl/tsan_string.cc	/^TEST(ThreadSanitizer, Memcpy) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_string.cc	/^TEST(ThreadSanitizer, MemcpyRace1) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_string.cc	/^TEST(ThreadSanitizer, MemcpyRace2) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_string.cc	/^TEST(ThreadSanitizer, MemcpyRace3) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_string.cc	/^TEST(ThreadSanitizer, MemcpyStack) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_string.cc	/^TEST(ThreadSanitizer, MemsetRace1) {$/;"	f	namespace:__tsan
TEST	tests/rtl/tsan_test.cc	/^TEST(ThreadSanitizer, FuncCall) {$/;"	f
TEST	tests/rtl/tsan_thread.cc	/^TEST(DISABLED_SLOW_ThreadSanitizer, ThreadALot) {$/;"	f
TEST	tests/rtl/tsan_thread.cc	/^TEST(ThreadSanitizer, ThreadDetach1) {$/;"	f
TEST	tests/rtl/tsan_thread.cc	/^TEST(ThreadSanitizer, ThreadDetach2) {$/;"	f
TEST	tests/rtl/tsan_thread.cc	/^TEST(ThreadSanitizer, ThreadSync) {$/;"	f
TEST	tests/unit/tsan_clock_test.cc	/^TEST(Clock, AcquireRelease) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_clock_test.cc	/^TEST(Clock, ChunkedBasic) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_clock_test.cc	/^TEST(Clock, DifferentSizes) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_clock_test.cc	/^TEST(Clock, Fuzzer) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_clock_test.cc	/^TEST(Clock, Growth) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_clock_test.cc	/^TEST(Clock, ManyThreads) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_clock_test.cc	/^TEST(Clock, RepeatedAcquire) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_clock_test.cc	/^TEST(Clock, VectorBasic) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_dense_alloc_test.cc	/^TEST(DenseSlabAlloc, Basic) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_flags_test.cc	/^TEST(Flags, Basic) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_flags_test.cc	/^TEST(Flags, DefaultValues) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_flags_test.cc	/^TEST(Flags, ParseDefaultOptions) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_flags_test.cc	/^TEST(Flags, ParseEnvOptions) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_flags_test.cc	/^TEST(Flags, ParsePriority) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mman_test.cc	/^TEST(Mman, CallocOverflow) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mman_test.cc	/^TEST(Mman, Internal) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mman_test.cc	/^TEST(Mman, Stats) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mman_test.cc	/^TEST(Mman, UsableSize) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mman_test.cc	/^TEST(Mman, User) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mman_test.cc	/^TEST(Mman, UserRealloc) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutex_test.cc	/^TEST(Mutex, ReadWrite) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutex_test.cc	/^TEST(Mutex, SpinWrite) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutex_test.cc	/^TEST(Mutex, Write) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutexset_test.cc	/^TEST(MutexSet, Basic) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutexset_test.cc	/^TEST(MutexSet, DoubleAdd) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutexset_test.cc	/^TEST(MutexSet, DoubleDel) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutexset_test.cc	/^TEST(MutexSet, Full) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutexset_test.cc	/^TEST(MutexSet, Overflow) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_mutexset_test.cc	/^TEST(MutexSet, Remove) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_shadow_test.cc	/^TEST(Shadow, Celling) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_shadow_test.cc	/^TEST(Shadow, FastState) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_shadow_test.cc	/^TEST(Shadow, Mapping) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_stack_test.cc	/^TEST(StackTrace, BasicBuffered) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_stack_test.cc	/^TEST(StackTrace, BasicVarSize) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_stack_test.cc	/^TEST(StackTrace, TrimBuffered) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_stack_test.cc	/^TEST(StackTrace, TrimVarSize) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_sync_test.cc	/^TEST(MetaMap, Basic) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_sync_test.cc	/^TEST(MetaMap, FreeRange) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_sync_test.cc	/^TEST(MetaMap, MoveMemory) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_sync_test.cc	/^TEST(MetaMap, ResetSync) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_sync_test.cc	/^TEST(MetaMap, Sync) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_vector_test.cc	/^TEST(Vector, Basic) {$/;"	f	namespace:__tsan
TEST	tests/unit/tsan_vector_test.cc	/^TEST(Vector, Stride) {$/;"	f	namespace:__tsan
TSAN_CLOCK_H	rtl/tsan_clock.h	14;"	d
TSAN_DEBUG	rtl/tsan_defs.h	22;"	d
TSAN_DEFS_H	rtl/tsan_defs.h	15;"	d
TSAN_DENSE_ALLOC_H	rtl/tsan_dense_alloc.h	20;"	d
TSAN_FD_H	rtl/tsan_fd.h	35;"	d
TSAN_FLAGS_H	rtl/tsan_flags.h	15;"	d
TSAN_IGNORESET_H	rtl/tsan_ignoreset.h	15;"	d
TSAN_INTERCEPT	rtl/tsan_interceptors.cc	234;"	d	file:
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(char*, strchr, char *s, int c) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(char*, strchrnul, char *s, int c) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(char*, strcpy, char *dst, const char *src) {  \/\/ NOLINT$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(char*, strdup, const char *str) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(char*, strncpy, char *dst, char *src, uptr n) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(char*, strrchr, char *s, int c) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(const char*, strstr, const char *s1, const char *s2) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, __close, int fd) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, __cxa_atexit, void (*f)(void *a), void *arg, void *dso) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, __fxstat, int version, int fd, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, __fxstat64, int version, int fd, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, __lxstat, int version, const char *path, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, __lxstat64, int version, const char *path, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, __xstat, int version, const char *path, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, __xstat64, int version, const char *path, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, atexit, void (*f)()) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, bind, int fd, void *addr, unsigned addrlen) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, close, int fd) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, connect, int fd, void *addr, unsigned addrlen) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, creat, const char *name, int mode) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, creat64, const char *name, int mode) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, dup, int oldfd) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, dup2, int oldfd, int newfd) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, dup3, int oldfd, int newfd, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, epoll_create, int size) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, epoll_create1, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, eventfd, unsigned initval, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, fork, int fake) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, fstat, int fd, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, fstat64, int fd, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, getaddrinfo, void *node, void *service,$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, gettimeofday, void *tv, void *tz) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, inotify_init, int fake) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, inotify_init1, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, kill, int pid, int sig) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, listen, int fd, int backlog) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, lstat, const char *path, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, lstat64, const char *path, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, memcmp, const void *s1, const void *s2, uptr n) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, nanosleep, void *req, void *rem) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, on_exit, void(*f)(int, void*), void *arg) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, open, const char *name, int flags, int mode) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, open64, const char *name, int flags, int mode) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pipe, int *pipefd) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pipe2, int *pipefd, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, posix_memalign, void **memptr, uptr align, uptr sz) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_barrier_destroy, void *b) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_barrier_init, void *b, void *a, unsigned count) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_barrier_wait, void *b) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_create,$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_detach, void *th) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_join, void *th, void **ret) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_kill, void *tid, int sig) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_mutex_destroy, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_mutex_init, void *m, void *a) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_mutex_trylock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_destroy, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_init, void *m, void *a) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_rdlock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_timedrdlock, void *m, void *abstime) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_timedwrlock, void *m, void *abstime) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_tryrdlock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_trywrlock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_unlock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_rwlock_wrlock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_spin_destroy, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_spin_init, void *m, int pshared) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_spin_lock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_spin_trylock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, pthread_spin_unlock, void *m) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, puts, const char *s) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, raise, int sig) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, rmdir, char *path) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sem_destroy, void *s) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sem_getvalue, void *s, int *sval) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sem_init, void *s, int pshared, unsigned value) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sem_post, void *s) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sem_timedwait, void *s, void *abstime) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sem_trywait, void *s) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sem_wait, void *s) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sigaction, int sig, sigaction_t *act, sigaction_t *old) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, signalfd, int fd, void *mask, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, sigsuspend, const __sanitizer_sigset_t *mask) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, socket, int domain, int type, int protocol) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, socketpair, int domain, int type, int protocol, int *fd) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, stat, const char *path, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, stat64, const char *path, void *buf) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, unlink, char *path) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, usleep, long_t usec) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(int, vfork, int fake) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(long_t, recv, int fd, void *buf, long_t len, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(long_t, send, int fd, void *buf, long_t len, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(long_t, sendmsg, int fd, void *msg, int flags) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(sighandler_t, signal, int sig, sighandler_t h) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(unsigned, sleep, unsigned sec) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(uptr, fread, void *ptr, uptr size, uptr nmemb, void *f) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(uptr, fwrite, const void *p, uptr size, uptr nmemb, void *f) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(uptr, malloc_usable_size, void *p) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(uptr, strlen, const char *s) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, __libc_memalign, uptr align, uptr sz) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, aligned_alloc, uptr align, uptr sz) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, malloc, uptr size) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, memcpy, void *dst, const void *src, uptr size) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, memmove, void *dst, void *src, uptr n) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, memset, void *dst, int v, uptr size) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, mmap, void *addr, long_t sz, int prot,$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, mmap64, void *addr, long_t sz, int prot,$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, opendir, char *path) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, realloc, void *p, uptr size) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, tmpfile, int fake) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, tmpfile64, int fake) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void*, valloc, uptr sz) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void, __res_iclose, void *state, bool free_addr) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void, abort, int fake) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void, cfree, void *p) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void, free, void *p) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void, longjmp, uptr *env, int val) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	/^TSAN_INTERCEPTOR(void, siglongjmp, uptr *env, int val) {$/;"	f
TSAN_INTERCEPTOR	rtl/tsan_interceptors.cc	233;"	d	file:
TSAN_INTERCEPT_VER	rtl/tsan_interceptors.cc	236;"	d	file:
TSAN_INTERCEPT_VER	rtl/tsan_interceptors.cc	238;"	d	file:
TSAN_INTERFACE_ANN_H	rtl/tsan_interface_ann.h	15;"	d
TSAN_INTERFACE_H	rtl/tsan_interface.h	17;"	d
TSAN_INTERFACE_JAVA_H	rtl/tsan_interface_java.h	25;"	d
TSAN_MAYBE_INTERCEPT_CREAT64	rtl/tsan_interceptors.cc	1518;"	d	file:
TSAN_MAYBE_INTERCEPT_CREAT64	rtl/tsan_interceptors.cc	1520;"	d	file:
TSAN_MAYBE_INTERCEPT_EPOLL_CREATE	rtl/tsan_interceptors.cc	1650;"	d	file:
TSAN_MAYBE_INTERCEPT_EPOLL_CREATE	rtl/tsan_interceptors.cc	1652;"	d	file:
TSAN_MAYBE_INTERCEPT_EPOLL_CREATE1	rtl/tsan_interceptors.cc	1663;"	d	file:
TSAN_MAYBE_INTERCEPT_EPOLL_CREATE1	rtl/tsan_interceptors.cc	1665;"	d	file:
TSAN_MAYBE_INTERCEPT_EPOLL_CTL	rtl/tsan_interceptors.cc	1842;"	d	file:
TSAN_MAYBE_INTERCEPT_EPOLL_CTL	rtl/tsan_interceptors.cc	1844;"	d	file:
TSAN_MAYBE_INTERCEPT_EPOLL_WAIT	rtl/tsan_interceptors.cc	1857;"	d	file:
TSAN_MAYBE_INTERCEPT_EPOLL_WAIT	rtl/tsan_interceptors.cc	1859;"	d	file:
TSAN_MAYBE_INTERCEPT_EVENTFD	rtl/tsan_interceptors.cc	1555;"	d	file:
TSAN_MAYBE_INTERCEPT_EVENTFD	rtl/tsan_interceptors.cc	1557;"	d	file:
TSAN_MAYBE_INTERCEPT_FSTAT64	rtl/tsan_interceptors.cc	1476;"	d	file:
TSAN_MAYBE_INTERCEPT_FSTAT64	rtl/tsan_interceptors.cc	1478;"	d	file:
TSAN_MAYBE_INTERCEPT_INOTIFY_INIT	rtl/tsan_interceptors.cc	1583;"	d	file:
TSAN_MAYBE_INTERCEPT_INOTIFY_INIT	rtl/tsan_interceptors.cc	1585;"	d	file:
TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1	rtl/tsan_interceptors.cc	1596;"	d	file:
TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1	rtl/tsan_interceptors.cc	1598;"	d	file:
TSAN_MAYBE_INTERCEPT_LSTAT64	rtl/tsan_interceptors.cc	1426;"	d	file:
TSAN_MAYBE_INTERCEPT_LSTAT64	rtl/tsan_interceptors.cc	1428;"	d	file:
TSAN_MAYBE_INTERCEPT_MEMALIGN	rtl/tsan_interceptors.cc	780;"	d	file:
TSAN_MAYBE_INTERCEPT_MEMALIGN	rtl/tsan_interceptors.cc	782;"	d	file:
TSAN_MAYBE_INTERCEPT_MMAP64	rtl/tsan_interceptors.cc	763;"	d	file:
TSAN_MAYBE_INTERCEPT_MMAP64	rtl/tsan_interceptors.cc	765;"	d	file:
TSAN_MAYBE_INTERCEPT_OPEN64	rtl/tsan_interceptors.cc	1497;"	d	file:
TSAN_MAYBE_INTERCEPT_OPEN64	rtl/tsan_interceptors.cc	1499;"	d	file:
TSAN_MAYBE_INTERCEPT_PVALLOC	rtl/tsan_interceptors.cc	801;"	d	file:
TSAN_MAYBE_INTERCEPT_PVALLOC	rtl/tsan_interceptors.cc	803;"	d	file:
TSAN_MAYBE_INTERCEPT_SIGNALFD	rtl/tsan_interceptors.cc	1570;"	d	file:
TSAN_MAYBE_INTERCEPT_SIGNALFD	rtl/tsan_interceptors.cc	1572;"	d	file:
TSAN_MAYBE_INTERCEPT_STAT64	rtl/tsan_interceptors.cc	1386;"	d	file:
TSAN_MAYBE_INTERCEPT_STAT64	rtl/tsan_interceptors.cc	1388;"	d	file:
TSAN_MAYBE_INTERCEPT_TMPFILE64	rtl/tsan_interceptors.cc	1780;"	d	file:
TSAN_MAYBE_INTERCEPT_TMPFILE64	rtl/tsan_interceptors.cc	1782;"	d	file:
TSAN_MAYBE_INTERCEPT___CLOSE	rtl/tsan_interceptors.cc	1682;"	d	file:
TSAN_MAYBE_INTERCEPT___CLOSE	rtl/tsan_interceptors.cc	1684;"	d	file:
TSAN_MAYBE_INTERCEPT___FXSTAT	rtl/tsan_interceptors.cc	1438;"	d	file:
TSAN_MAYBE_INTERCEPT___FXSTAT	rtl/tsan_interceptors.cc	1440;"	d	file:
TSAN_MAYBE_INTERCEPT___FXSTAT64	rtl/tsan_interceptors.cc	1464;"	d	file:
TSAN_MAYBE_INTERCEPT___FXSTAT64	rtl/tsan_interceptors.cc	1466;"	d	file:
TSAN_MAYBE_INTERCEPT___LXSTAT	rtl/tsan_interceptors.cc	1396;"	d	file:
TSAN_MAYBE_INTERCEPT___LXSTAT	rtl/tsan_interceptors.cc	1398;"	d	file:
TSAN_MAYBE_INTERCEPT___LXSTAT64	rtl/tsan_interceptors.cc	1416;"	d	file:
TSAN_MAYBE_INTERCEPT___LXSTAT64	rtl/tsan_interceptors.cc	1418;"	d	file:
TSAN_MAYBE_INTERCEPT___RES_ICLOSE	rtl/tsan_interceptors.cc	1699;"	d	file:
TSAN_MAYBE_INTERCEPT___RES_ICLOSE	rtl/tsan_interceptors.cc	1701;"	d	file:
TSAN_MAYBE_INTERCEPT___XSTAT	rtl/tsan_interceptors.cc	1356;"	d	file:
TSAN_MAYBE_INTERCEPT___XSTAT	rtl/tsan_interceptors.cc	1358;"	d	file:
TSAN_MAYBE_INTERCEPT___XSTAT64	rtl/tsan_interceptors.cc	1376;"	d	file:
TSAN_MAYBE_INTERCEPT___XSTAT64	rtl/tsan_interceptors.cc	1378;"	d	file:
TSAN_MMAN_H	rtl/tsan_mman.h	14;"	d
TSAN_MUTEXSET_H	rtl/tsan_mutexset.h	15;"	d
TSAN_MUTEX_H	rtl/tsan_mutex.h	14;"	d
TSAN_PLATFORM_H	rtl/tsan_platform.h	16;"	d
TSAN_REPORT_H	rtl/tsan_report.h	14;"	d
TSAN_RTL_H	rtl/tsan_rtl.h	27;"	d
TSAN_SHADOW_COUNT	rtl/tsan_defs.h	56;"	d
TSAN_STACK_TRACE_H	rtl/tsan_stack_trace.h	14;"	d
TSAN_STAT_H	rtl/tsan_stat.h	15;"	d
TSAN_SUPPRESSIONS_H	rtl/tsan_suppressions.h	14;"	d
TSAN_SYMBOLIZE_H	rtl/tsan_symbolize.h	14;"	d
TSAN_SYNC_H	rtl/tsan_sync.h	14;"	d
TSAN_SYSCALL	rtl/tsan_interceptors.cc	2252;"	d	file:
TSAN_TEST_UTIL_H	tests/rtl/tsan_test_util.h	15;"	d
TSAN_TRACE_H	rtl/tsan_trace.h	14;"	d
TSAN_VECTOR_H	rtl/tsan_vector.h	17;"	d
TestData	tests/unit/tsan_mutex_test.cc	/^  explicit TestData(MutexType *mtx)$/;"	f	class:__tsan::TestData
TestData	tests/unit/tsan_mutex_test.cc	/^class TestData {$/;"	c	namespace:__tsan	file:
TestMutexBeforeInit	tests/rtl/tsan_test_util_linux.cc	/^void TestMutexBeforeInit() {$/;"	f
TestStackTrace	tests/unit/tsan_stack_test.cc	/^static void TestStackTrace(StackTraceTy *trace) {$/;"	f	namespace:__tsan
TestTrim	tests/unit/tsan_stack_test.cc	/^static void TestTrim(StackTraceTy *trace) {$/;"	f	namespace:__tsan
Thread	benchmarks/mini_bench_local.cc	/^void *Thread(void *arg) {$/;"	f
Thread	benchmarks/mini_bench_shared.cc	/^void *Thread(void *arg) {$/;"	f
Thread	benchmarks/start_many_threads.cc	/^void* Thread(void *unused) {$/;"	f
Thread	benchmarks/vts_many_threads_bench.cc	/^void *Thread(void *arg) {$/;"	f
Thread	dd/dd_rtl.h	/^struct Thread {$/;"	s	namespace:__dsan
Thread1	mytest/simple_race.cc	/^void *Thread1(void *x) {$/;"	f
Thread2	mytest/simple_race.cc	/^void *Thread2(void *x) {$/;"	f
Thread3	mytest/simple_race.cc	/^void *Thread3(void *x) {$/;"	f
Thread4	mytest/simple_race.cc	/^void *Thread4(void *x) {$/;"	f
ThreadCheckIgnore	rtl/tsan_rtl_thread.cc	/^static void ThreadCheckIgnore(ThreadState *thr) {$/;"	f	namespace:__tsan
ThreadCheckIgnore	rtl/tsan_rtl_thread.cc	/^static void ThreadCheckIgnore(ThreadState *thr) {}$/;"	f	namespace:__tsan
ThreadClock	rtl/tsan_clock.cc	/^ThreadClock::ThreadClock(unsigned tid, unsigned reused)$/;"	f	class:__tsan::ThreadClock
ThreadContext	rtl/tsan_rtl.h	/^class ThreadContext : public ThreadContextBase {$/;"	c	namespace:__tsan
ThreadContext	rtl/tsan_rtl_thread.cc	/^ThreadContext::ThreadContext(int tid)$/;"	f	class:__tsan::ThreadContext
ThreadCount	rtl/tsan_rtl_thread.cc	/^int ThreadCount(ThreadState *thr) {$/;"	f	namespace:__tsan
ThreadCreate	rtl/tsan_rtl_thread.cc	/^int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {$/;"	f	namespace:__tsan
ThreadDescription	rtl/tsan_report.cc	/^  const char *ThreadDescription()    { return Cyan(); }$/;"	f	class:__tsan::Decorator
ThreadDestroy	dd/dd_rtl.cc	/^void ThreadDestroy(Thread *thr) {$/;"	f	namespace:__dsan
ThreadDetach	rtl/tsan_rtl_thread.cc	/^void ThreadDetach(ThreadState *thr, uptr pc, int tid) {$/;"	f	namespace:__tsan
ThreadFinalize	rtl/tsan_rtl_thread.cc	/^void ThreadFinalize(ThreadState *thr) {$/;"	f	namespace:__tsan
ThreadFinish	rtl/tsan_rtl_thread.cc	/^void ThreadFinish(ThreadState *thr) {$/;"	f	namespace:__tsan
ThreadIgnoreBegin	rtl/tsan_rtl.cc	/^void ThreadIgnoreBegin(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
ThreadIgnoreEnd	rtl/tsan_rtl.cc	/^void ThreadIgnoreEnd(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
ThreadIgnoreSyncBegin	rtl/tsan_rtl.cc	/^void ThreadIgnoreSyncBegin(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
ThreadIgnoreSyncEnd	rtl/tsan_rtl.cc	/^void ThreadIgnoreSyncEnd(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
ThreadInit	dd/dd_rtl.cc	/^void ThreadInit(Thread *thr) {$/;"	f	namespace:__dsan
ThreadJoin	rtl/tsan_rtl_thread.cc	/^void ThreadJoin(ThreadState *thr, uptr pc, int tid) {$/;"	f	namespace:__tsan
ThreadLeak	rtl/tsan_rtl_thread.cc	/^struct ThreadLeak {$/;"	s	namespace:__tsan	file:
ThreadParam	rtl/tsan_interceptors.cc	/^struct ThreadParam {$/;"	s	file:
ThreadSanitizerQuery	rtl/tsan_interface_ann.cc	/^const char INTERFACE_ATTRIBUTE* ThreadSanitizerQuery(const char *query) {$/;"	f
ThreadSetName	rtl/tsan_rtl_thread.cc	/^void ThreadSetName(ThreadState *thr, const char *name) {$/;"	f	namespace:__tsan
ThreadStart	rtl/tsan_rtl_thread.cc	/^void ThreadStart(ThreadState *thr, int tid, uptr os_id) {$/;"	f	namespace:__tsan
ThreadState	rtl/tsan_rtl.cc	/^ThreadState::ThreadState(Context *ctx, int tid, int unique_id, u64 epoch,$/;"	f	class:__tsan::ThreadState
ThreadState	rtl/tsan_rtl.h	/^struct ThreadState {$/;"	s	namespace:__tsan
ThreadTid	rtl/tsan_rtl_thread.cc	/^int ThreadTid(ThreadState *thr, uptr pc, uptr uid) {$/;"	f	namespace:__tsan
ThreadTrace	rtl/tsan_rtl.cc	/^Trace *ThreadTrace(int tid) {$/;"	f	namespace:__tsan
Thread_bug1	mytest/four_races.c	/^void *Thread_bug1(void *x) {$/;"	f
Thread_bug2	mytest/four_races.c	/^void *Thread_bug2(void *x) {$/;"	f
Thread_bug3	mytest/four_races.c	/^void *Thread_bug3(void *x) {$/;"	f
Thread_bug4	mytest/four_races.c	/^void *Thread_bug4(void *x) {$/;"	f
TidWithIgnore	rtl/tsan_rtl.h	/^  u64 TidWithIgnore() const {$/;"	f	class:__tsan::FastState
TidsAreEqual	rtl/tsan_rtl.h	/^  static inline bool TidsAreEqual(const Shadow s1, const Shadow s2) {$/;"	f	class:__tsan::Shadow
Trace	rtl/tsan_trace.h	/^  Trace()$/;"	f	struct:__tsan::Trace
Trace	rtl/tsan_trace.h	/^struct Trace {$/;"	s	namespace:__tsan
TraceAddEvent	rtl/tsan_rtl.h	/^void ALWAYS_INLINE TraceAddEvent(ThreadState *thr, FastState fs,$/;"	f	namespace:__tsan
TraceHeader	rtl/tsan_trace.h	/^  TraceHeader() : stack0(), epoch0() {}$/;"	f	struct:__tsan::TraceHeader
TraceHeader	rtl/tsan_trace.h	/^struct TraceHeader {$/;"	s	namespace:__tsan
TraceParts	rtl/tsan_rtl.cc	/^uptr TraceParts() {$/;"	f	namespace:__tsan
TraceSize	rtl/tsan_rtl.cc	/^uptr TraceSize() {$/;"	f	namespace:__tsan
TraceSwitch	rtl/tsan_rtl.cc	/^void TraceSwitch(ThreadState *thr) {$/;"	f	namespace:__tsan
TraceTopPC	rtl/tsan_rtl.cc	/^uptr TraceTopPC(ThreadState *thr) {$/;"	f	namespace:__tsan
TryLock	tests/rtl/tsan_test_util_linux.cc	/^bool Mutex::TryLock() {$/;"	f	class:Mutex
TryLock	tests/rtl/tsan_test_util_linux.cc	/^bool ScopedThread::TryLock(const Mutex &m) {$/;"	f	class:ScopedThread
TryReadLock	tests/rtl/tsan_test_util_linux.cc	/^bool Mutex::TryReadLock() {$/;"	f	class:Mutex
TryReadLock	tests/rtl/tsan_test_util_linux.cc	/^bool ScopedThread::TryReadLock(const Mutex &m) {$/;"	f	class:ScopedThread
TsanCheckFailed	rtl/tsan_rtl_report.cc	/^void TsanCheckFailed(const char *file, int line, const char *cond,$/;"	f	namespace:__tsan
TsanFunctions	Makefile.mk	/^TsanFunctions :=$/;"	m
TsanInterceptorContext	rtl/tsan_interceptors.cc	/^struct TsanInterceptorContext {$/;"	s	file:
TwoRangesIntersect	rtl/tsan_rtl.h	/^  static ALWAYS_INLINE bool TwoRangesIntersect(Shadow s1, Shadow s2,$/;"	f	class:__tsan::Shadow
TwoRangesIntersectSlow	rtl/tsan_rtl.h	/^  static bool TwoRangesIntersectSlow(const Shadow s1, const Shadow s2) {$/;"	f	class:__tsan::Shadow
Type	tests/rtl/tsan_test_util.h	/^  enum Type { Normal, Spin, RW };$/;"	g	class:Mutex
Type	tests/rtl/tsan_test_util_linux.cc	/^  enum Type {$/;"	g	struct:Event	file:
UnalignedMemoryAccess	rtl/tsan_rtl.cc	/^void UnalignedMemoryAccess(ThreadState *thr, uptr pc, uptr addr,$/;"	f	namespace:__tsan
UniqueTid	rtl/tsan_rtl_mutex.cc	/^  virtual int UniqueTid() {$/;"	f	struct:__tsan::Callback
Unlock	benchmarks/vts_many_threads_bench.cc	/^  void Unlock() { pthread_mutex_unlock(&m_); }$/;"	f	class:Mutex
Unlock	rtl/tsan_mutex.cc	/^void InternalDeadlockDetector::Unlock(MutexType t) {$/;"	f	class:__tsan::InternalDeadlockDetector
Unlock	rtl/tsan_mutex.cc	/^void Mutex::Unlock() {$/;"	f	class:__tsan::Mutex
Unlock	tests/rtl/tsan_test_util_linux.cc	/^void Mutex::Unlock() {$/;"	f	class:Mutex
Unlock	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Unlock(const Mutex &m) {$/;"	f	class:ScopedThread
Unwind	dd/dd_rtl.cc	/^u32 Callback::Unwind() {$/;"	f	class:__dsan::Callback
Unwind	rtl/tsan_rtl_mutex.cc	/^  virtual u32 Unwind() {$/;"	f	struct:__tsan::Callback
UpdateClockCallback	rtl/tsan_rtl_mutex.cc	/^static void UpdateClockCallback(ThreadContextBase *tctx_base, void *arg) {$/;"	f	namespace:__tsan
UpdateCurrentThread	rtl/tsan_clock.cc	/^void ThreadClock::UpdateCurrentThread(SyncClock *dst) const {$/;"	f	class:__tsan::ThreadClock
UpdateSleepClockCallback	rtl/tsan_rtl_mutex.cc	/^static void UpdateSleepClockCallback(ThreadContextBase *tctx_base, void *arg) {$/;"	f	namespace:__tsan
UserRegions	rtl/tsan_platform.h	/^static USED uptr UserRegions[] = {$/;"	m	namespace:__tsan
VPTR_UPDATE	tests/rtl/tsan_test_util_linux.cc	/^    VPTR_UPDATE,$/;"	e	enum:Event::Type	file:
ValgrindSlowdown	rtl/tsan_interface_ann.cc	/^double __attribute__((weak)) INTERFACE_ATTRIBUTE ValgrindSlowdown(void) {$/;"	f
VarSizeStackTrace	rtl/tsan_stack_trace.cc	/^VarSizeStackTrace::VarSizeStackTrace()$/;"	f	class:__tsan::VarSizeStackTrace
VarSizeStackTrace	rtl/tsan_stack_trace.h	/^struct VarSizeStackTrace : public StackTrace {$/;"	s	namespace:__tsan
Vector	rtl/tsan_vector.h	/^  explicit Vector(MBlockType typ)$/;"	f	class:__tsan::Vector
Vector	rtl/tsan_vector.h	/^class Vector {$/;"	c	namespace:__tsan
VerifyOptions1	tests/unit/tsan_flags_test.cc	/^void VerifyOptions1(Flags *f) {$/;"	f	namespace:__tsan
VerifyOptions2	tests/unit/tsan_flags_test.cc	/^void VerifyOptions2(Flags *f) {$/;"	f	namespace:__tsan
VptrUpdate	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::VptrUpdate(const MemLoc &vptr,$/;"	f	class:ScopedThread
WRITE	tests/rtl/tsan_test_util_linux.cc	/^    WRITE,$/;"	e	enum:Event::Type	file:
WTFAnnotateBenignRaceSized	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE WTFAnnotateBenignRaceSized($/;"	f
WTFAnnotateHappensAfter	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE WTFAnnotateHappensAfter(char *f, int l, uptr addr) {$/;"	f
WTFAnnotateHappensBefore	rtl/tsan_interface_ann.cc	/^void INTERFACE_ATTRIBUTE WTFAnnotateHappensBefore(char *f, int l, uptr addr) {$/;"	f
Warning	rtl/tsan_report.cc	/^  const char *Warning()    { return Red(); }$/;"	f	class:__tsan::Decorator
Write	tests/rtl/tsan_test_util.h	/^  void Write(const MemLoc &ml, int size, bool expect_race = false) {$/;"	f	class:ScopedThread
Write	tests/unit/tsan_mutex_test.cc	/^  void Write() {$/;"	f	class:__tsan::TestData
Write1	tests/rtl/tsan_test_util.h	/^  void Write1(const MemLoc &ml, bool expect_race = false) {$/;"	f	class:ScopedThread
Write2	tests/rtl/tsan_test_util.h	/^  void Write2(const MemLoc &ml, bool expect_race = false) {$/;"	f	class:ScopedThread
Write4	tests/rtl/tsan_test_util.h	/^  void Write4(const MemLoc &ml, bool expect_race = false) {$/;"	f	class:ScopedThread
Write8	tests/rtl/tsan_test_util.h	/^  void Write8(const MemLoc &ml, bool expect_race = false) {$/;"	f	class:ScopedThread
WriteMemoryProfile	rtl/tsan_platform_linux.cc	/^void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive) {$/;"	f	namespace:__tsan
WriteMemoryProfile	rtl/tsan_platform_mac.cc	/^void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive) {$/;"	f	namespace:__tsan
WriteMemoryProfile	rtl/tsan_platform_windows.cc	/^void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive) {$/;"	f	namespace:__tsan
_MM_MALLOC_H_INCLUDED	rtl/tsan_rtl.cc	32;"	d	file:
__MM_MALLOC_H	rtl/tsan_rtl.cc	33;"	d	file:
__TSAN_HAS_INT128	rtl/tsan_interface_atomic.cc	38;"	d	file:
__TSAN_HAS_INT128	rtl/tsan_interface_atomic.cc	40;"	d	file:
__cxa_guard_abort	rtl/tsan_interceptors.cc	/^extern "C" void INTERFACE_ATTRIBUTE __cxa_guard_abort(atomic_uint32_t *g) {$/;"	f
__cxa_guard_acquire	rtl/tsan_interceptors.cc	/^extern "C" int INTERFACE_ATTRIBUTE __cxa_guard_acquire(atomic_uint32_t *g) {$/;"	f
__cxa_guard_release	rtl/tsan_interceptors.cc	/^extern "C" void INTERFACE_ATTRIBUTE __cxa_guard_release(atomic_uint32_t *g) {$/;"	f
__dsan	dd/dd_interceptors.cc	/^namespace __dsan {$/;"	n	file:
__dsan	dd/dd_rtl.cc	/^namespace __dsan {$/;"	n	file:
__dsan	dd/dd_rtl.h	/^namespace __dsan {$/;"	n
__dsan_after_mutex_lock	dd/dd_interceptors.cc	/^void __dsan_after_mutex_lock(uptr m, int writelock, int trylock) {$/;"	f
__dsan_before_mutex_lock	dd/dd_interceptors.cc	/^void __dsan_before_mutex_lock(uptr m, int writelock) {$/;"	f
__dsan_before_mutex_unlock	dd/dd_interceptors.cc	/^void __dsan_before_mutex_unlock(uptr m, int writelock) {$/;"	f
__dsan_mutex_destroy	dd/dd_interceptors.cc	/^void __dsan_mutex_destroy(uptr m) {$/;"	f
__errno_location	rtl/tsan_interceptors.cc	33;"	d	file:
__interceptor___sigsetjmp	rtl/tsan_interceptors.cc	/^extern "C" int __interceptor___sigsetjmp(void *env) {$/;"	f
__interceptor__setjmp	rtl/tsan_interceptors.cc	/^extern "C" int __interceptor__setjmp(void *env) {$/;"	f
__interceptor_setjmp	rtl/tsan_interceptors.cc	/^extern "C" int __interceptor_setjmp(void *env) {$/;"	f
__interceptor_sigsetjmp	rtl/tsan_interceptors.cc	/^extern "C" int __interceptor_sigsetjmp(void *env) {$/;"	f
__libc_calloc	rtl/tsan_interceptors.cc	36;"	d	file:
__libc_free	rtl/tsan_interceptors.cc	37;"	d	file:
__libc_malloc	rtl/tsan_interceptors.cc	34;"	d	file:
__libc_realloc	rtl/tsan_interceptors.cc	35;"	d	file:
__libc_stack_end	rtl/tsan_platform_linux.cc	/^extern "C" void *__libc_stack_end;$/;"	v
__libc_stack_end	rtl/tsan_platform_linux.cc	/^void *__libc_stack_end = 0;$/;"	v
__need_res_state	rtl/tsan_platform_linux.cc	47;"	d	file:
__sanitizer	go/tsan_go.cc	/^namespace __sanitizer {$/;"	n	file:
__sanitizer_free_hook	rtl/tsan_mman.cc	/^extern "C" void WEAK __sanitizer_free_hook(void *ptr) {$/;"	f
__sanitizer_get_allocated_size	rtl/tsan_mman.cc	/^uptr __sanitizer_get_allocated_size(const void *p) {$/;"	f
__sanitizer_get_current_allocated_bytes	rtl/tsan_mman.cc	/^uptr __sanitizer_get_current_allocated_bytes() {$/;"	f
__sanitizer_get_estimated_allocated_size	rtl/tsan_mman.cc	/^uptr __sanitizer_get_estimated_allocated_size(uptr size) {$/;"	f
__sanitizer_get_free_bytes	rtl/tsan_mman.cc	/^uptr __sanitizer_get_free_bytes() {$/;"	f
__sanitizer_get_heap_size	rtl/tsan_mman.cc	/^uptr __sanitizer_get_heap_size() {$/;"	f
__sanitizer_get_ownership	rtl/tsan_mman.cc	/^int __sanitizer_get_ownership(const void *p) {$/;"	f
__sanitizer_get_unmapped_bytes	rtl/tsan_mman.cc	/^uptr __sanitizer_get_unmapped_bytes() {$/;"	f
__sanitizer_malloc_hook	rtl/tsan_mman.cc	/^extern "C" void WEAK __sanitizer_malloc_hook(void *ptr, uptr size) {$/;"	f
__sanitizer_print_stack_trace	rtl/tsan_rtl_report.cc	/^void __sanitizer_print_stack_trace() {$/;"	f
__sigsetjmp	rtl/tsan_rtl_amd64.S	/^__sigsetjmp:$/;"	l
__tsan	go/tsan_go.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_clock.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_clock.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_defs.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_dense_alloc.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_fd.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_fd.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_flags.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_flags.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_ignoreset.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_ignoreset.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_interceptors.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_interface_ann.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_interface_java.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_md5.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_mman.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_mman.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_mutex.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_mutex.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_mutexset.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_mutexset.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_platform.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_platform_linux.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_platform_mac.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_platform_windows.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_report.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_report.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_rtl.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_rtl.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_rtl_mutex.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_rtl_report.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_rtl_thread.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_stack_trace.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_stack_trace.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_stat.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_stat.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_suppressions.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_suppressions.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_symbolize.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_symbolize.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_sync.cc	/^namespace __tsan {$/;"	n	file:
__tsan	rtl/tsan_sync.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_trace.h	/^namespace __tsan {$/;"	n
__tsan	rtl/tsan_vector.h	/^namespace __tsan {$/;"	n
__tsan	tests/rtl/tsan_mutex.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/rtl/tsan_string.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/rtl/tsan_test_util_linux.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_clock_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_dense_alloc_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_flags_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_mman_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_mutex_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_mutexset_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_shadow_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_stack_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_sync_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan	tests/unit/tsan_vector_test.cc	/^namespace __tsan {$/;"	n	file:
__tsan_acquire	go/tsan_go.cc	/^void __tsan_acquire(ThreadState *thr, void *addr) {$/;"	f
__tsan_acquire	rtl/tsan_interface.cc	/^void __tsan_acquire(void *addr) {$/;"	f
__tsan_atomic128_compare_exchange_strong	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic128_compare_exchange_strong(volatile a128 *a, a128 *c, a128 v,$/;"	f
__tsan_atomic128_compare_exchange_val	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_compare_exchange_val(volatile a128 *a, a128 c, a128 v,$/;"	f
__tsan_atomic128_compare_exchange_weak	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic128_compare_exchange_weak(volatile a128 *a, a128 *c, a128 v,$/;"	f
__tsan_atomic128_exchange	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_exchange(volatile a128 *a, a128 v, morder mo) {$/;"	f
__tsan_atomic128_fetch_add	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_fetch_add(volatile a128 *a, a128 v, morder mo) {$/;"	f
__tsan_atomic128_fetch_and	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_fetch_and(volatile a128 *a, a128 v, morder mo) {$/;"	f
__tsan_atomic128_fetch_nand	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_fetch_nand(volatile a128 *a, a128 v, morder mo) {$/;"	f
__tsan_atomic128_fetch_or	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_fetch_or(volatile a128 *a, a128 v, morder mo) {$/;"	f
__tsan_atomic128_fetch_sub	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_fetch_sub(volatile a128 *a, a128 v, morder mo) {$/;"	f
__tsan_atomic128_fetch_xor	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_fetch_xor(volatile a128 *a, a128 v, morder mo) {$/;"	f
__tsan_atomic128_load	rtl/tsan_interface_atomic.cc	/^a128 __tsan_atomic128_load(const volatile a128 *a, morder mo) {$/;"	f
__tsan_atomic128_store	rtl/tsan_interface_atomic.cc	/^void __tsan_atomic128_store(volatile a128 *a, a128 v, morder mo) {$/;"	f
__tsan_atomic16_compare_exchange_strong	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic16_compare_exchange_strong(volatile a16 *a, a16 *c, a16 v,$/;"	f
__tsan_atomic16_compare_exchange_val	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_compare_exchange_val(volatile a16 *a, a16 c, a16 v,$/;"	f
__tsan_atomic16_compare_exchange_weak	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic16_compare_exchange_weak(volatile a16 *a, a16 *c, a16 v,$/;"	f
__tsan_atomic16_exchange	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_exchange(volatile a16 *a, a16 v, morder mo) {$/;"	f
__tsan_atomic16_fetch_add	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_fetch_add(volatile a16 *a, a16 v, morder mo) {$/;"	f
__tsan_atomic16_fetch_and	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_fetch_and(volatile a16 *a, a16 v, morder mo) {$/;"	f
__tsan_atomic16_fetch_nand	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_fetch_nand(volatile a16 *a, a16 v, morder mo) {$/;"	f
__tsan_atomic16_fetch_or	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_fetch_or(volatile a16 *a, a16 v, morder mo) {$/;"	f
__tsan_atomic16_fetch_sub	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_fetch_sub(volatile a16 *a, a16 v, morder mo) {$/;"	f
__tsan_atomic16_fetch_xor	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_fetch_xor(volatile a16 *a, a16 v, morder mo) {$/;"	f
__tsan_atomic16_load	rtl/tsan_interface_atomic.cc	/^a16 __tsan_atomic16_load(const volatile a16 *a, morder mo) {$/;"	f
__tsan_atomic16_store	rtl/tsan_interface_atomic.cc	/^void __tsan_atomic16_store(volatile a16 *a, a16 v, morder mo) {$/;"	f
__tsan_atomic32_compare_exchange_strong	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic32_compare_exchange_strong(volatile a32 *a, a32 *c, a32 v,$/;"	f
__tsan_atomic32_compare_exchange_val	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_compare_exchange_val(volatile a32 *a, a32 c, a32 v,$/;"	f
__tsan_atomic32_compare_exchange_weak	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic32_compare_exchange_weak(volatile a32 *a, a32 *c, a32 v,$/;"	f
__tsan_atomic32_exchange	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_exchange(volatile a32 *a, a32 v, morder mo) {$/;"	f
__tsan_atomic32_fetch_add	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_fetch_add(volatile a32 *a, a32 v, morder mo) {$/;"	f
__tsan_atomic32_fetch_and	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_fetch_and(volatile a32 *a, a32 v, morder mo) {$/;"	f
__tsan_atomic32_fetch_nand	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_fetch_nand(volatile a32 *a, a32 v, morder mo) {$/;"	f
__tsan_atomic32_fetch_or	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_fetch_or(volatile a32 *a, a32 v, morder mo) {$/;"	f
__tsan_atomic32_fetch_sub	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_fetch_sub(volatile a32 *a, a32 v, morder mo) {$/;"	f
__tsan_atomic32_fetch_xor	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_fetch_xor(volatile a32 *a, a32 v, morder mo) {$/;"	f
__tsan_atomic32_load	rtl/tsan_interface_atomic.cc	/^a32 __tsan_atomic32_load(const volatile a32 *a, morder mo) {$/;"	f
__tsan_atomic32_store	rtl/tsan_interface_atomic.cc	/^void __tsan_atomic32_store(volatile a32 *a, a32 v, morder mo) {$/;"	f
__tsan_atomic64_compare_exchange_strong	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic64_compare_exchange_strong(volatile a64 *a, a64 *c, a64 v,$/;"	f
__tsan_atomic64_compare_exchange_val	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_compare_exchange_val(volatile a64 *a, a64 c, a64 v,$/;"	f
__tsan_atomic64_compare_exchange_weak	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic64_compare_exchange_weak(volatile a64 *a, a64 *c, a64 v,$/;"	f
__tsan_atomic64_exchange	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_exchange(volatile a64 *a, a64 v, morder mo) {$/;"	f
__tsan_atomic64_fetch_add	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_fetch_add(volatile a64 *a, a64 v, morder mo) {$/;"	f
__tsan_atomic64_fetch_and	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_fetch_and(volatile a64 *a, a64 v, morder mo) {$/;"	f
__tsan_atomic64_fetch_nand	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_fetch_nand(volatile a64 *a, a64 v, morder mo) {$/;"	f
__tsan_atomic64_fetch_or	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_fetch_or(volatile a64 *a, a64 v, morder mo) {$/;"	f
__tsan_atomic64_fetch_sub	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_fetch_sub(volatile a64 *a, a64 v, morder mo) {$/;"	f
__tsan_atomic64_fetch_xor	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_fetch_xor(volatile a64 *a, a64 v, morder mo) {$/;"	f
__tsan_atomic64_load	rtl/tsan_interface_atomic.cc	/^a64 __tsan_atomic64_load(const volatile a64 *a, morder mo) {$/;"	f
__tsan_atomic64_store	rtl/tsan_interface_atomic.cc	/^void __tsan_atomic64_store(volatile a64 *a, a64 v, morder mo) {$/;"	f
__tsan_atomic8_compare_exchange_strong	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic8_compare_exchange_strong(volatile a8 *a, a8 *c, a8 v,$/;"	f
__tsan_atomic8_compare_exchange_val	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_compare_exchange_val(volatile a8 *a, a8 c, a8 v,$/;"	f
__tsan_atomic8_compare_exchange_weak	rtl/tsan_interface_atomic.cc	/^int __tsan_atomic8_compare_exchange_weak(volatile a8 *a, a8 *c, a8 v,$/;"	f
__tsan_atomic8_exchange	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_exchange(volatile a8 *a, a8 v, morder mo) {$/;"	f
__tsan_atomic8_fetch_add	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_fetch_add(volatile a8 *a, a8 v, morder mo) {$/;"	f
__tsan_atomic8_fetch_and	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_fetch_and(volatile a8 *a, a8 v, morder mo) {$/;"	f
__tsan_atomic8_fetch_nand	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_fetch_nand(volatile a8 *a, a8 v, morder mo) {$/;"	f
__tsan_atomic8_fetch_or	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_fetch_or(volatile a8 *a, a8 v, morder mo) {$/;"	f
__tsan_atomic8_fetch_sub	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_fetch_sub(volatile a8 *a, a8 v, morder mo) {$/;"	f
__tsan_atomic8_fetch_xor	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_fetch_xor(volatile a8 *a, a8 v, morder mo) {$/;"	f
__tsan_atomic8_load	rtl/tsan_interface_atomic.cc	/^a8 __tsan_atomic8_load(const volatile a8 *a, morder mo) {$/;"	f
__tsan_atomic8_store	rtl/tsan_interface_atomic.cc	/^void __tsan_atomic8_store(volatile a8 *a, a8 v, morder mo) {$/;"	f
__tsan_atomic_signal_fence	rtl/tsan_interface_atomic.cc	/^void __tsan_atomic_signal_fence(morder mo) {$/;"	f
__tsan_atomic_thread_fence	rtl/tsan_interface_atomic.cc	/^void __tsan_atomic_thread_fence(morder mo) {$/;"	f
__tsan_default_options	rtl/tsan_flags.cc	/^const char *WEAK __tsan_default_options() {$/;"	f	namespace:__tsan
__tsan_default_options	tests/unit/tsan_flags_test.cc	/^extern "C" const char *__tsan_default_options() {$/;"	f	namespace:__tsan
__tsan_default_suppressions	rtl/tsan_suppressions.cc	/^extern "C" const char *WEAK __tsan_default_suppressions() {$/;"	f
__tsan_finalizer_goroutine	go/tsan_go.cc	/^void __tsan_finalizer_goroutine(ThreadState *thr) {$/;"	f
__tsan_fini	go/tsan_go.cc	/^void __tsan_fini() {$/;"	f
__tsan_func_enter	go/tsan_go.cc	/^void __tsan_func_enter(ThreadState *thr, void *pc) {$/;"	f
__tsan_func_entry	rtl/tsan_interface_inl.h	/^void __tsan_func_entry(void *pc) {$/;"	f
__tsan_func_exit	go/tsan_go.cc	/^void __tsan_func_exit(ThreadState *thr) {$/;"	f
__tsan_func_exit	rtl/tsan_interface_inl.h	/^void __tsan_func_exit() {$/;"	f
__tsan_go_atomic32_compare_exchange	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic32_compare_exchange($/;"	f
__tsan_go_atomic32_exchange	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic32_exchange(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {$/;"	f
__tsan_go_atomic32_fetch_add	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic32_fetch_add(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {$/;"	f
__tsan_go_atomic32_load	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic32_load(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {$/;"	f
__tsan_go_atomic32_store	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic32_store(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {$/;"	f
__tsan_go_atomic64_compare_exchange	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic64_compare_exchange($/;"	f
__tsan_go_atomic64_exchange	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic64_exchange(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {$/;"	f
__tsan_go_atomic64_fetch_add	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic64_fetch_add(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {$/;"	f
__tsan_go_atomic64_load	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic64_load(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {$/;"	f
__tsan_go_atomic64_store	rtl/tsan_interface_atomic.cc	/^void __tsan_go_atomic64_store(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {$/;"	f
__tsan_go_end	go/tsan_go.cc	/^void __tsan_go_end(ThreadState *thr) {$/;"	f
__tsan_go_ignore_sync_begin	go/tsan_go.cc	/^void __tsan_go_ignore_sync_begin(ThreadState *thr) {$/;"	f
__tsan_go_ignore_sync_end	go/tsan_go.cc	/^void __tsan_go_ignore_sync_end(ThreadState *thr) {$/;"	f
__tsan_go_start	go/tsan_go.cc	/^void __tsan_go_start(ThreadState *parent, ThreadState **pthr, void *pc) {$/;"	f
__tsan_init	go/tsan_go.cc	/^void __tsan_init(ThreadState **thrp, void (*cb)(SymbolizeContext *cb)) {$/;"	f
__tsan_init	rtl/tsan_interface.cc	/^void __tsan_init() {$/;"	f
__tsan_java_alloc	rtl/tsan_interface_java.cc	/^void __tsan_java_alloc(jptr ptr, jptr size) {$/;"	f
__tsan_java_finalize	rtl/tsan_interface_java.cc	/^void __tsan_java_finalize() {$/;"	f
__tsan_java_fini	rtl/tsan_interface_java.cc	/^int  __tsan_java_fini() {$/;"	f
__tsan_java_free	rtl/tsan_interface_java.cc	/^void __tsan_java_free(jptr ptr, jptr size) {$/;"	f
__tsan_java_init	rtl/tsan_interface_java.cc	/^void __tsan_java_init(jptr heap_begin, jptr heap_size) {$/;"	f
__tsan_java_move	rtl/tsan_interface_java.cc	/^void __tsan_java_move(jptr src, jptr dst, jptr size) {$/;"	f
__tsan_java_mutex_lock	rtl/tsan_interface_java.cc	/^void __tsan_java_mutex_lock(jptr addr) {$/;"	f
__tsan_java_mutex_lock_rec	rtl/tsan_interface_java.cc	/^void __tsan_java_mutex_lock_rec(jptr addr, int rec) {$/;"	f
__tsan_java_mutex_read_lock	rtl/tsan_interface_java.cc	/^void __tsan_java_mutex_read_lock(jptr addr) {$/;"	f
__tsan_java_mutex_read_unlock	rtl/tsan_interface_java.cc	/^void __tsan_java_mutex_read_unlock(jptr addr) {$/;"	f
__tsan_java_mutex_unlock	rtl/tsan_interface_java.cc	/^void __tsan_java_mutex_unlock(jptr addr) {$/;"	f
__tsan_java_mutex_unlock_rec	rtl/tsan_interface_java.cc	/^int __tsan_java_mutex_unlock_rec(jptr addr) {$/;"	f
__tsan_malloc	go/tsan_go.cc	/^void __tsan_malloc(void *p, uptr sz) {$/;"	f
__tsan_map_shadow	go/tsan_go.cc	/^void __tsan_map_shadow(uptr addr, uptr size) {$/;"	f
__tsan_mutex_after_lock	go/tsan_go.cc	/^void __tsan_mutex_after_lock(ThreadState *thr, uptr addr, uptr write) {$/;"	f
__tsan_mutex_before_lock	go/tsan_go.cc	/^void __tsan_mutex_before_lock(ThreadState *thr, uptr addr, uptr write) {$/;"	f
__tsan_mutex_before_unlock	go/tsan_go.cc	/^void __tsan_mutex_before_unlock(ThreadState *thr, uptr addr, uptr write) {$/;"	f
__tsan_on_thread_idle	rtl/tsan_mman.cc	/^void __tsan_on_thread_idle() {$/;"	f
__tsan_read	go/tsan_go.cc	/^void __tsan_read(ThreadState *thr, void *addr, void *pc) {$/;"	f
__tsan_read1	rtl/tsan_interface_inl.h	/^void __tsan_read1(void *addr) {$/;"	f
__tsan_read16	rtl/tsan_interface.cc	/^void __tsan_read16(void *addr) {$/;"	f
__tsan_read2	rtl/tsan_interface_inl.h	/^void __tsan_read2(void *addr) {$/;"	f
__tsan_read4	rtl/tsan_interface_inl.h	/^void __tsan_read4(void *addr) {$/;"	f
__tsan_read8	rtl/tsan_interface_inl.h	/^void __tsan_read8(void *addr) {$/;"	f
__tsan_read_pc	go/tsan_go.cc	/^void __tsan_read_pc(ThreadState *thr, void *addr, uptr callpc, uptr pc) {$/;"	f
__tsan_read_range	go/tsan_go.cc	/^void __tsan_read_range(ThreadState *thr, void *addr, uptr size, uptr pc) {$/;"	f
__tsan_read_range	rtl/tsan_interface_inl.h	/^void __tsan_read_range(void *addr, uptr size) {$/;"	f
__tsan_release	go/tsan_go.cc	/^void __tsan_release(ThreadState *thr, void *addr) {$/;"	f
__tsan_release	rtl/tsan_interface.cc	/^void __tsan_release(void *addr) {$/;"	f
__tsan_release_merge	go/tsan_go.cc	/^void __tsan_release_merge(ThreadState *thr, void *addr) {$/;"	f
__tsan_report_race	rtl/tsan_rtl.cc	/^extern "C" void __tsan_report_race() {$/;"	f	namespace:__tsan
__tsan_report_race_thunk	rtl/tsan_rtl_amd64.S	/^__tsan_report_race_thunk:$/;"	l
__tsan_resume	rtl/tsan_rtl.cc	/^extern "C" void __tsan_resume() {$/;"	f
__tsan_resumed	rtl/tsan_rtl.cc	/^volatile int __tsan_resumed = 0;$/;"	v
__tsan_setjmp	rtl/tsan_interceptors.cc	/^extern "C" void __tsan_setjmp(uptr sp, uptr mangled_sp) {$/;"	f
__tsan_symbolize_external	rtl/tsan_symbolize.cc	/^bool __tsan_symbolize_external(uptr pc,$/;"	f	namespace:__tsan
__tsan_thread_start_func	rtl/tsan_interceptors.cc	/^extern "C" void *__tsan_thread_start_func(void *arg) {$/;"	f
__tsan_trace_switch	rtl/tsan_rtl.cc	/^extern "C" void __tsan_trace_switch() {$/;"	f	namespace:__tsan
__tsan_trace_switch_thunk	rtl/tsan_rtl_amd64.S	/^__tsan_trace_switch_thunk:$/;"	l
__tsan_unaligned_read2	rtl/tsan_interface.cc	/^u16 __tsan_unaligned_read2(const uu16 *addr) {$/;"	f
__tsan_unaligned_read4	rtl/tsan_interface.cc	/^u32 __tsan_unaligned_read4(const uu32 *addr) {$/;"	f
__tsan_unaligned_read8	rtl/tsan_interface.cc	/^u64 __tsan_unaligned_read8(const uu64 *addr) {$/;"	f
__tsan_unaligned_write2	rtl/tsan_interface.cc	/^void __tsan_unaligned_write2(uu16 *addr, u16 v) {$/;"	f
__tsan_unaligned_write4	rtl/tsan_interface.cc	/^void __tsan_unaligned_write4(uu32 *addr, u32 v) {$/;"	f
__tsan_unaligned_write8	rtl/tsan_interface.cc	/^void __tsan_unaligned_write8(uu64 *addr, u64 v) {$/;"	f
__tsan_vptr_read	rtl/tsan_interface_inl.h	/^void __tsan_vptr_read(void **vptr_p) {$/;"	f
__tsan_vptr_update	rtl/tsan_interface_inl.h	/^void __tsan_vptr_update(void **vptr_p, void *new_val) {$/;"	f
__tsan_write	go/tsan_go.cc	/^void __tsan_write(ThreadState *thr, void *addr, void *pc) {$/;"	f
__tsan_write1	rtl/tsan_interface_inl.h	/^void __tsan_write1(void *addr) {$/;"	f
__tsan_write16	rtl/tsan_interface.cc	/^void __tsan_write16(void *addr) {$/;"	f
__tsan_write2	rtl/tsan_interface_inl.h	/^void __tsan_write2(void *addr) {$/;"	f
__tsan_write4	rtl/tsan_interface_inl.h	/^void __tsan_write4(void *addr) {$/;"	f
__tsan_write8	rtl/tsan_interface_inl.h	/^void __tsan_write8(void *addr) {$/;"	f
__tsan_write_pc	go/tsan_go.cc	/^void __tsan_write_pc(ThreadState *thr, void *addr, uptr callpc, uptr pc) {$/;"	f
__tsan_write_range	go/tsan_go.cc	/^void __tsan_write_range(ThreadState *thr, void *addr, uptr size, uptr pc) {$/;"	f
__tsan_write_range	rtl/tsan_interface_inl.h	/^void __tsan_write_range(void *addr, uptr size) {$/;"	f
_setjmp	rtl/tsan_rtl_amd64.S	/^_setjmp:$/;"	l
a	benchmarks/mini_bench_local.cc	/^int *a;$/;"	v
a	benchmarks/mini_bench_shared.cc	/^int *a;$/;"	v
a	rtl/tsan_md5.cc	/^  MD5_u32plus a, b, c, d;$/;"	m	struct:__tsan::__anon5	file:
a128	rtl/tsan_interface_atomic.cc	/^__extension__ typedef __int128 a128;$/;"	t	file:
a16	rtl/tsan_interface_atomic.cc	/^typedef unsigned short     a16;  \/\/ NOLINT$/;"	t	file:
a32	rtl/tsan_interface_atomic.cc	/^typedef unsigned int       a32;$/;"	t	file:
a64	rtl/tsan_interface_atomic.cc	/^typedef unsigned long long a64;  \/\/ NOLINT$/;"	t	file:
a8	rtl/tsan_interface_atomic.cc	/^typedef unsigned char      a8;$/;"	t	file:
acq_rel	rtl/tsan_clock.cc	/^void ThreadClock::acq_rel(ClockCache *c, SyncClock *dst) {$/;"	f	class:__tsan::ThreadClock
acq_rel	tests/unit/tsan_clock_test.cc	/^  void acq_rel(SimpleSyncClock *dst) {$/;"	f	struct:__tsan::SimpleThreadClock
acquire	rtl/tsan_clock.cc	/^void ThreadClock::acquire(ClockCache *c, const SyncClock *src) {$/;"	f	class:__tsan::ThreadClock
acquire	tests/unit/tsan_clock_test.cc	/^  void acquire(const SimpleSyncClock *src) {$/;"	f	struct:__tsan::SimpleThreadClock
addcount	rtl/tsan_interface_ann.cc	/^  int addcount;$/;"	m	struct:__tsan::ExpectRace	file:
addr	rtl/tsan_interface_ann.cc	/^  uptr addr;$/;"	m	struct:__tsan::ExpectRace	file:
addr	rtl/tsan_report.h	/^  uptr addr;$/;"	m	struct:__tsan::ReportMop
addr	rtl/tsan_report.h	/^  uptr addr;$/;"	m	struct:__tsan::ReportMutex
addr	rtl/tsan_sync.h	/^  uptr addr;  \/\/ overwritten by DenseSlabAlloc freelist$/;"	m	struct:__tsan::SyncVar
addr0	rtl/tsan_rtl.h	/^  u64 ALWAYS_INLINE addr0() const { return (x_ >> kClkBits) & 7; }$/;"	f	class:__tsan::Shadow
addr_max	rtl/tsan_rtl.h	/^  uptr addr_max;$/;"	m	struct:__tsan::RacyAddress
addr_min	rtl/tsan_rtl.h	/^  uptr addr_min;$/;"	m	struct:__tsan::RacyAddress
after_multithreaded_fork	rtl/tsan_rtl.h	/^  bool after_multithreaded_fork;$/;"	m	struct:__tsan::Context
alive_	tests/rtl/tsan_test_util.h	/^  bool alive_;$/;"	m	class:Mutex
all_threads_ready	benchmarks/start_many_threads.cc	/^pthread_barrier_t all_threads_ready;$/;"	v
all_threads_ready	benchmarks/vts_many_threads_bench.cc	/^pthread_barrier_t all_threads_ready, main_threads_ready;$/;"	v
alloc_cache	rtl/tsan_rtl.h	/^  AllocatorCache alloc_cache;$/;"	m	struct:__tsan::ThreadState
alloc_counter	rtl/tsan_report.h	/^  uptr alloc_counter;$/;"	m	class:__tsan::ReportDesc
alloc_counter	rtl/tsan_rtl.h	/^  uptr alloc_counter;$/;"	m	struct:__tsan::ThreadState
allocate_addr	tests/rtl/tsan_test_util_linux.cc	/^static void* allocate_addr(int size, int offset_from_aligned = 0) {$/;"	f	file:
allocator	rtl/tsan_mman.cc	/^Allocator *allocator() {$/;"	f	namespace:__tsan
allocsync	rtl/tsan_fd.cc	/^static FdSync *allocsync(ThreadState *thr, uptr pc) {$/;"	f	namespace:__tsan
arg	rtl/tsan_interceptors.cc	/^  void *arg;$/;"	m	struct:AtExitCtx	file:
arg	tests/rtl/tsan_test_util_linux.cc	/^  uptr arg;$/;"	m	struct:Event	file:
arg2	tests/rtl/tsan_test_util_linux.cc	/^  uptr arg2;$/;"	m	struct:Event	file:
argv0	tests/rtl/tsan_test.cc	/^const char *argv0;$/;"	v
armed	rtl/tsan_interceptors.cc	/^  bool armed;$/;"	m	struct:__tsan::SignalDesc	file:
at_exit_wrapper	rtl/tsan_interceptors.cc	/^static void at_exit_wrapper(void *arg) {$/;"	f	file:
atexit_sleep_ms	rtl/tsan_flags.h	/^  int atexit_sleep_ms;$/;"	m	struct:__tsan::Flags
atomic	rtl/tsan_report.h	/^  bool atomic;$/;"	m	struct:__tsan::ReportMop
b	rtl/tsan_md5.cc	/^  MD5_u32plus a, b, c, d;$/;"	m	struct:__tsan::__anon5	file:
background_thread	rtl/tsan_rtl.h	/^  void *background_thread;$/;"	m	struct:__tsan::Context
bar	tests/rtl/tsan_mop.cc	/^static void bar() {$/;"	f	file:
bar	tests/rtl/tsan_test.cc	/^static void bar() {}$/;"	f	file:
barfoo	go/test.c	/^void barfoo() {}$/;"	f
begin_	rtl/tsan_vector.h	/^  T *begin_;$/;"	m	class:__tsan::Vector
benign	rtl/tsan_interface_ann.cc	/^  ExpectRace benign;$/;"	m	struct:__tsan::DynamicAnnContext	file:
block	rtl/tsan_md5.cc	/^  MD5_u32plus block[16];$/;"	m	struct:__tsan::__anon5	file:
block_cache	rtl/tsan_rtl.h	/^  DenseSlabAllocCache block_cache;$/;"	m	struct:__tsan::ThreadState
body	rtl/tsan_md5.cc	/^static const void *body(MD5_CTX *ctx, const void *data, ulong_t size) {$/;"	f	namespace:__tsan
bogusfd	rtl/tsan_fd.cc	/^static bool bogusfd(int fd) {$/;"	f	namespace:__tsan
buf0	go/test.c	/^char buf0[100<<10];$/;"	v
buffer	rtl/tsan_md5.cc	/^  unsigned char buffer[64];$/;"	m	struct:__tsan::__anon5	file:
build_consistency	rtl/tsan_defs.h	/^static inline void USED build_consistency() {$/;"	f	namespace:__tsan
build_consistency_debug	rtl/tsan_rtl.cc	/^void build_consistency_debug() {}$/;"	f	namespace:__tsan
build_consistency_nostats	rtl/tsan_rtl.cc	/^void build_consistency_nostats() {}$/;"	f	namespace:__tsan
build_consistency_release	rtl/tsan_rtl.cc	/^void build_consistency_release() {}$/;"	f	namespace:__tsan
build_consistency_shadow1	rtl/tsan_rtl.cc	/^void build_consistency_shadow1() {}$/;"	f	namespace:__tsan
build_consistency_shadow2	rtl/tsan_rtl.cc	/^void build_consistency_shadow2() {}$/;"	f	namespace:__tsan
build_consistency_shadow4	rtl/tsan_rtl.cc	/^void build_consistency_shadow4() {}$/;"	f	namespace:__tsan
build_consistency_shadow8	rtl/tsan_rtl.cc	/^void build_consistency_shadow8() {}$/;"	f	namespace:__tsan
build_consistency_stats	rtl/tsan_rtl.cc	/^void build_consistency_stats() {}$/;"	f	namespace:__tsan
c	rtl/tsan_md5.cc	/^  MD5_u32plus a, b, c, d;$/;"	m	struct:__tsan::__anon5	file:
c	tests/rtl/tsan_posix.cc	/^  pthread_cond_t c;$/;"	m	struct:CondContext	file:
cache	rtl/tsan_dense_alloc.h	/^  IndexT cache[kSize];$/;"	m	class:__tsan::DenseSlabAllocCache
cache	tests/unit/tsan_clock_test.cc	/^ClockCache cache;$/;"	m	namespace:__tsan	file:
call_pthread_cancel_with_cleanup	rtl/tsan_platform_linux.cc	/^int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,$/;"	f	namespace:__tsan
call_pthread_cancel_with_cleanup	rtl/tsan_platform_mac.cc	/^int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,$/;"	f	namespace:__tsan
callback	rtl/tsan_interceptors.cc	/^  void* (*callback)(void *arg);$/;"	m	struct:ThreadParam	file:
caller_pc	rtl/tsan_interceptors.cc	/^  const uptr caller_pc;$/;"	m	struct:TsanInterceptorContext	file:
check	check_analyze.sh	/^check() {$/;"	f
clock	rtl/tsan_clock.h	/^    ClockElem clock[kClockCount];$/;"	m	union:__tsan::ClockBlock::__anon3
clock	rtl/tsan_rtl.h	/^  ThreadClock clock;$/;"	m	struct:__tsan::ThreadState
clock	rtl/tsan_sync.h	/^  SyncClock clock;$/;"	m	struct:__tsan::SyncVar
clock	tests/unit/tsan_clock_test.cc	/^  u64 clock[kThreads];$/;"	m	struct:__tsan::SimpleSyncClock	file:
clock	tests/unit/tsan_clock_test.cc	/^  u64 clock[kThreads];$/;"	m	struct:__tsan::SimpleThreadClock	file:
clock_alloc	rtl/tsan_rtl.h	/^  ClockAlloc clock_alloc;$/;"	m	struct:__tsan::Context
clock_cache	rtl/tsan_rtl.h	/^  DenseSlabAllocCache clock_cache;$/;"	m	struct:__tsan::ThreadState
cnt	tests/rtl/tsan_posix.cc	/^  int *cnt;$/;"	m	struct:thread_key	file:
cond_mutex_unlock	rtl/tsan_interceptors.cc	/^static void cond_mutex_unlock(CondMutexUnlockCtx *arg) {$/;"	f	file:
cond_thread	tests/rtl/tsan_posix.cc	/^static void *cond_thread(void *p) {$/;"	f	file:
connectsync	rtl/tsan_fd.cc	/^  u64 connectsync;$/;"	m	struct:__tsan::FdContext	file:
conv	rtl/tsan_suppressions.cc	/^SuppressionType conv(ReportType typ) {$/;"	f	namespace:__tsan
count	rtl/tsan_mutexset.h	/^    int count;$/;"	m	struct:__tsan::MutexSet::Desc
count	rtl/tsan_report.h	/^  int count;$/;"	m	class:__tsan::ReportDesc
count	rtl/tsan_rtl_thread.cc	/^  int count;$/;"	m	struct:__tsan::ThreadLeak	file:
creation_stack	rtl/tsan_fd.cc	/^  u32 creation_stack;$/;"	m	struct:__tsan::FdDesc	file:
creation_stack_id	rtl/tsan_rtl.h	/^  u32 creation_stack_id;$/;"	m	class:__tsan::ThreadContext
creation_stack_id	rtl/tsan_sync.h	/^  u32 creation_stack_id;$/;"	m	struct:__tsan::SyncVar
creation_tid	rtl/tsan_fd.cc	/^  int creation_tid;$/;"	m	struct:__tsan::FdDesc	file:
ctx	dd/dd_rtl.cc	/^static Context *ctx;$/;"	m	namespace:__dsan	file:
ctx	rtl/tsan_interceptors.cc	/^  SignalContext *ctx;$/;"	m	struct:BlockingCall	file:
ctx	rtl/tsan_interceptors.cc	/^  ucontext_t ctx;$/;"	m	struct:__tsan::SignalDesc	file:
ctx	rtl/tsan_rtl.cc	/^Context *ctx;$/;"	m	namespace:__tsan	file:
cur_thread	rtl/tsan_rtl.h	/^INLINE ThreadState *cur_thread() {$/;"	f	namespace:__tsan
d	rtl/tsan_md5.cc	/^  MD5_u32plus a, b, c, d;$/;"	m	struct:__tsan::__anon5	file:
data	tests/rtl/tsan_posix.cc	/^  int data;$/;"	m	struct:CondContext	file:
data_	tests/unit/tsan_mutex_test.cc	/^  T data_[kSize];$/;"	m	class:__tsan::TestData	file:
dd	dd/dd_rtl.h	/^  DDMutex dd;$/;"	m	struct:__dsan::Mutex
dd	dd/dd_rtl.h	/^  DDetector *dd;$/;"	m	struct:__dsan::Context
dd	rtl/tsan_rtl.h	/^  DDetector *dd;$/;"	m	struct:__tsan::Context
dd	rtl/tsan_sync.h	/^  DDMutex dd;$/;"	m	struct:__tsan::SyncVar
dd_lt	dd/dd_rtl.h	/^  DDLogicalThread *dd_lt;$/;"	m	struct:__dsan::Thread
dd_lt	rtl/tsan_rtl.h	/^  DDLogicalThread *dd_lt;$/;"	m	struct:__tsan::ThreadState
dd_pt	dd/dd_rtl.h	/^  DDPhysicalThread *dd_pt;$/;"	m	struct:__dsan::Thread
dd_pt	rtl/tsan_rtl.h	/^  DDPhysicalThread *dd_pt;$/;"	m	struct:__tsan::ThreadState
desc	rtl/tsan_interface_ann.cc	/^  char desc[kMaxDescLen];$/;"	m	struct:__tsan::ExpectRace	file:
descs_	rtl/tsan_mutexset.h	/^  Desc descs_[kMaxSize];$/;"	m	class:__tsan::MutexSet
destroyed	rtl/tsan_report.h	/^  bool destroyed;$/;"	m	struct:__tsan::ReportMutex
detached	tests/rtl/tsan_test_util_linux.cc	/^  bool detached;$/;"	m	struct:ScopedThread::Impl	file:
die_after_fork	rtl/tsan_flags.h	/^  bool die_after_fork;$/;"	m	struct:__tsan::Flags
dtors_thread	tests/rtl/tsan_posix.cc	/^static void *dtors_thread(void *p) {$/;"	f	file:
dyn_ann_ctx	rtl/tsan_interface_ann.cc	/^static DynamicAnnContext *dyn_ann_ctx;$/;"	m	namespace:__tsan	file:
elem	rtl/tsan_clock.cc	/^ClockElem &SyncClock::elem(unsigned tid) const {$/;"	f	class:__tsan::SyncClock
enable_annotations	rtl/tsan_flags.h	/^  bool enable_annotations;$/;"	m	struct:__tsan::Flags
end_	rtl/tsan_vector.h	/^  T *end_;$/;"	m	class:__tsan::Vector
epoch	rtl/tsan_clock.h	/^  u64 epoch  : kClkBits;$/;"	m	struct:__tsan::ClockElem
epoch	rtl/tsan_mutexset.h	/^    u64 epoch;$/;"	m	struct:__tsan::MutexSet::Desc
epoch	rtl/tsan_rtl.h	/^  u64 epoch() const {$/;"	f	class:__tsan::FastState
epoch0	rtl/tsan_rtl.h	/^  u64 epoch0;$/;"	m	class:__tsan::ThreadContext
epoch0	rtl/tsan_trace.h	/^  u64        epoch0;  \/\/ Start epoch for the trace.$/;"	m	struct:__tsan::TraceHeader
epoch1	rtl/tsan_rtl.h	/^  u64 epoch1;$/;"	m	class:__tsan::ThreadContext
errno	rtl/tsan_interceptors.cc	106;"	d	file:
event	tests/rtl/tsan_test_util_linux.cc	/^  atomic_uintptr_t event;  \/\/ Event*$/;"	m	struct:ScopedThread::Impl	file:
exitcode	rtl/tsan_flags.h	/^  int exitcode;$/;"	m	struct:__tsan::Flags
expect	rtl/tsan_interface_ann.cc	/^  ExpectRace expect;$/;"	m	struct:__tsan::DynamicAnnContext	file:
expect_report	tests/rtl/tsan_test_util_linux.cc	/^  bool expect_report;$/;"	m	struct:Event	file:
expect_report	tests/rtl/tsan_test_util_linux.cc	/^static __thread bool expect_report;$/;"	v	file:
expect_report_reported	tests/rtl/tsan_test_util_linux.cc	/^static __thread bool expect_report_reported;$/;"	v	file:
expect_report_type	tests/rtl/tsan_test_util_linux.cc	/^static __thread ReportType expect_report_type;$/;"	v	file:
f	rtl/tsan_interceptors.cc	/^  void (*f)();$/;"	m	struct:AtExitCtx	file:
fast_state	rtl/tsan_rtl.h	/^  FastState fast_state;$/;"	m	struct:__tsan::ThreadState
fast_synch_epoch	rtl/tsan_rtl.h	/^  u64 fast_synch_epoch;$/;"	m	struct:__tsan::ThreadState
fd	rtl/tsan_report.h	/^  int fd;$/;"	m	struct:__tsan::ReportLocation
fdctx	rtl/tsan_fd.cc	/^static FdContext fdctx;$/;"	m	namespace:__tsan	file:
fddesc	rtl/tsan_fd.cc	/^static FdDesc *fddesc(ThreadState *thr, uptr pc, int fd) {$/;"	f	namespace:__tsan
file	go/tsan_go.cc	/^  char *file;$/;"	m	struct:__tsan::SymbolizeContext	file:
file	rtl/tsan_interface_ann.cc	/^  char *file;$/;"	m	struct:__tsan::ExpectRace	file:
filesync	rtl/tsan_fd.cc	/^  FdSync filesync;$/;"	m	struct:__tsan::FdContext	file:
fillpos_	rtl/tsan_dense_alloc.h	/^  uptr fillpos_;$/;"	m	class:__tsan::DenseSlabAlloc
finalize	rtl/tsan_interceptors.cc	/^static void finalize(void *arg) {$/;"	f	namespace:__tsan
fired_suppressions	rtl/tsan_rtl.h	/^  InternalMmapVector<FiredSuppression> fired_suppressions;$/;"	m	struct:__tsan::Context
fix_mmap_addr	rtl/tsan_interceptors.cc	/^static bool fix_mmap_addr(void **addr, long_t sz, int flags) {$/;"	f	file:
flags	dd/dd_rtl.h	/^inline Flags* flags() {$/;"	f	namespace:__dsan
flags	rtl/tsan_flags.cc	/^Flags *flags() {$/;"	f	namespace:__tsan
flags	rtl/tsan_rtl.h	/^  Flags flags;$/;"	m	struct:__tsan::Context
flush_memory_ms	rtl/tsan_flags.h	/^  int flush_memory_ms;$/;"	m	struct:__tsan::Flags
flush_symbolizer_ms	rtl/tsan_flags.h	/^  int flush_symbolizer_ms;$/;"	m	struct:__tsan::Flags
foo	tests/rtl/tsan_mop.cc	/^static void foo() {$/;"	f	file:
foo	tests/rtl/tsan_test.cc	/^static void foo() {}$/;"	f	file:
foobar	go/test.c	/^void foobar() {}$/;"	f
foobarbaz	tests/rtl/tsan_mop.cc	/^static void foobarbaz() {}$/;"	f	file:
force_seq_cst_atomics	rtl/tsan_flags.h	/^  bool force_seq_cst_atomics;$/;"	m	struct:__tsan::Flags
freelist_	rtl/tsan_dense_alloc.h	/^  IndexT freelist_;$/;"	m	class:__tsan::DenseSlabAlloc
fsanitize	mytest/Makefile	/^	..\/..\/..\/..\/..\/build\/bin\/clang four_races.c -fsanitize=thread -g -o four_races$/;"	m
fsanitize	mytest/Makefile	/^	..\/..\/..\/..\/..\/build_ori\/bin\/clang four_race.c -fsanitize=thread -g -o four_races$/;"	m
func	go/tsan_go.cc	/^  char *func;$/;"	m	struct:__tsan::SymbolizeContext	file:
func_add	rtl/tsan_interface_atomic.cc	/^a128 func_add(volatile a128 *v, a128 op) {$/;"	f
func_add	rtl/tsan_interface_atomic.cc	/^template<typename T> T func_add(volatile T *v, T op) {$/;"	f
func_and	rtl/tsan_interface_atomic.cc	/^a128 func_and(volatile a128 *v, a128 op) {$/;"	f
func_and	rtl/tsan_interface_atomic.cc	/^template<typename T> T func_and(volatile T *v, T op) {$/;"	f
func_cas	rtl/tsan_interface_atomic.cc	/^a128 func_cas(volatile a128 *v, a128 cmp, a128 xch) {$/;"	f
func_cas	rtl/tsan_interface_atomic.cc	/^template<typename T> T func_cas(volatile T *v, T cmp, T xch) {$/;"	f
func_nand	rtl/tsan_interface_atomic.cc	/^a128 func_nand(volatile a128 *v, a128 op) {$/;"	f
func_nand	rtl/tsan_interface_atomic.cc	/^template<typename T> T func_nand(volatile T *v, T op) {$/;"	f
func_or	rtl/tsan_interface_atomic.cc	/^a128 func_or(volatile a128 *v, a128 op) {$/;"	f
func_or	rtl/tsan_interface_atomic.cc	/^template<typename T> T func_or(volatile T *v, T op) {$/;"	f
func_sub	rtl/tsan_interface_atomic.cc	/^a128 func_sub(volatile a128 *v, a128 op) {$/;"	f
func_sub	rtl/tsan_interface_atomic.cc	/^template<typename T> T func_sub(volatile T *v, T op) {$/;"	f
func_xchg	rtl/tsan_interface_atomic.cc	/^a128 func_xchg(volatile a128 *v, a128 op) {$/;"	f
func_xchg	rtl/tsan_interface_atomic.cc	/^template<typename T> T func_xchg(volatile T *v, T op) {$/;"	f
func_xor	rtl/tsan_interface_atomic.cc	/^a128 func_xor(volatile a128 *v, a128 op) {$/;"	f
func_xor	rtl/tsan_interface_atomic.cc	/^template<typename T> T func_xor(volatile T *v, T op) {$/;"	f
g_data_end	dd/dd_interceptors.cc	/^static uptr g_data_end;$/;"	v	file:
g_data_end	rtl/tsan_platform_linux.cc	/^static uptr g_data_end;$/;"	m	namespace:__tsan	file:
g_data_start	dd/dd_interceptors.cc	/^static uptr g_data_start;$/;"	v	file:
g_data_start	rtl/tsan_platform_linux.cc	/^static uptr g_data_start;$/;"	m	namespace:__tsan	file:
g_thread_finalize_key	rtl/tsan_interceptors.cc	/^static unsigned g_thread_finalize_key;$/;"	v	file:
get_asm	analyze_libtsan.sh	/^get_asm() {$/;"	f
global	rtl/tsan_report.h	/^  DataInfo global;$/;"	m	struct:__tsan::ReportLocation
global1	mytest/four_races.c	/^int global1;$/;"	v
global2	mytest/four_races.c	/^int global2;$/;"	v
global3	mytest/four_races.c	/^int global3;$/;"	v
global4	mytest/four_races.c	/^int global4;$/;"	v
globsync	rtl/tsan_fd.cc	/^  FdSync globsync;$/;"	m	struct:__tsan::FdContext	file:
halt_on_error	rtl/tsan_flags.h	/^  bool halt_on_error;$/;"	m	struct:__tsan::Flags
hash	rtl/tsan_defs.h	/^  u64 hash[2];$/;"	m	struct:__tsan::MD5Hash
hash	rtl/tsan_rtl.h	/^  MD5Hash hash[2];$/;"	m	struct:__tsan::RacyStacks
have_pending_signals	rtl/tsan_interceptors.cc	/^  atomic_uintptr_t have_pending_signals;$/;"	m	struct:__tsan::SignalContext	file:
headers	rtl/tsan_trace.h	/^  TraceHeader headers[kTraceParts];$/;"	m	struct:__tsan::Trace
heap_begin	rtl/tsan_interface_java.cc	/^  const uptr heap_begin;$/;"	m	struct:__tsan::JavaContext	file:
heap_chunk_size	rtl/tsan_report.h	/^  uptr heap_chunk_size;$/;"	m	struct:__tsan::ReportLocation
heap_chunk_start	rtl/tsan_report.h	/^  uptr heap_chunk_start;$/;"	m	struct:__tsan::ReportLocation
heap_size	rtl/tsan_interface_java.cc	/^  const uptr heap_size;$/;"	m	struct:__tsan::JavaContext	file:
hi	rtl/tsan_md5.cc	/^  MD5_u32plus lo, hi;$/;"	m	struct:__tsan::__anon5	file:
history_size	rtl/tsan_flags.h	/^  int history_size;$/;"	m	struct:__tsan::Flags
hitcount	rtl/tsan_interface_ann.cc	/^  int hitcount;$/;"	m	struct:__tsan::ExpectRace	file:
id	rtl/tsan_mutexset.h	/^    u64 id;$/;"	m	struct:__tsan::MutexSet::Desc
id	rtl/tsan_report.h	/^  int id;$/;"	m	struct:__tsan::ReportThread
id	rtl/tsan_report.h	/^  u64 id;$/;"	m	struct:__tsan::ReportMopMutex
id	rtl/tsan_report.h	/^  u64 id;$/;"	m	struct:__tsan::ReportMutex
ignore_interceptors	dd/dd_rtl.h	/^  bool ignore_interceptors;$/;"	m	struct:__dsan::Thread
ignore_interceptors	rtl/tsan_rtl.h	/^  int ignore_interceptors;$/;"	m	struct:__tsan::ThreadState
ignore_interceptors_	rtl/tsan_rtl.h	/^  ScopedIgnoreInterceptors ignore_interceptors_;$/;"	m	class:__tsan::ScopedReport
ignore_reads_and_writes	rtl/tsan_rtl.h	/^  int ignore_reads_and_writes;$/;"	m	struct:__tsan::ThreadState
ignore_sync	rtl/tsan_rtl.h	/^  int ignore_sync;$/;"	m	struct:__tsan::ThreadState
impl_	tests/rtl/tsan_test_util.h	/^  Impl *impl_;$/;"	m	class:ScopedThread
in_blocking_func	rtl/tsan_interceptors.cc	/^  atomic_uintptr_t in_blocking_func;$/;"	m	struct:__tsan::SignalContext	file:
in_blocking_func	rtl/tsan_rtl.h	/^  bool in_blocking_func;$/;"	m	struct:__tsan::JmpBuf
in_ignored_lib	rtl/tsan_rtl.h	/^  bool in_ignored_lib;$/;"	m	struct:__tsan::ThreadState
in_ignored_lib_	rtl/tsan_interceptors.cc	/^  bool in_ignored_lib_;$/;"	m	class:ScopedInterceptor	file:
in_signal_handler	rtl/tsan_rtl.h	/^  atomic_uintptr_t in_signal_handler;$/;"	m	struct:__tsan::ThreadState
in_signal_handler	rtl/tsan_rtl.h	/^  uptr in_signal_handler;$/;"	m	struct:__tsan::JmpBuf
in_symbolizer	rtl/tsan_rtl.h	/^  bool in_symbolizer;$/;"	m	struct:__tsan::ThreadState
info	rtl/tsan_report.h	/^  AddressInfo info;$/;"	m	struct:__tsan::ReportStack
init	rtl/tsan_fd.cc	/^static void init(ThreadState *thr, uptr pc, int fd, FdSync *s) {$/;"	f	namespace:__tsan
init_cond	dd/dd_interceptors.cc	/^static pthread_cond_t *init_cond(pthread_cond_t *c, bool force = false) {$/;"	f	file:
init_cond	rtl/tsan_interceptors.cc	/^static void *init_cond(void *c, bool force = false) {$/;"	f	file:
inited	dd/dd_interceptors.cc	/^static bool inited;$/;"	v	file:
inited	go/tsan_go.cc	/^static bool inited;$/;"	v	file:
initialized	rtl/tsan_rtl.h	/^  bool initialized;$/;"	m	struct:__tsan::Context
initing	dd/dd_interceptors.cc	/^static __thread volatile int initing;$/;"	v	file:
int_alloc_cnt	rtl/tsan_rtl.h	/^  u64 int_alloc_cnt[MBlockTypeCount];$/;"	m	struct:__tsan::Context
int_alloc_siz	rtl/tsan_rtl.h	/^  u64 int_alloc_siz[MBlockTypeCount];$/;"	m	struct:__tsan::Context
int_signal_send	rtl/tsan_interceptors.cc	/^  int int_signal_send;$/;"	m	struct:__tsan::SignalContext	file:
int_signal_send	rtl/tsan_rtl.h	/^  int int_signal_send;$/;"	m	struct:__tsan::JmpBuf
internal_alloc	go/tsan_go.cc	/^void *internal_alloc(MBlockType typ, uptr sz) {$/;"	f	namespace:__tsan
internal_alloc	rtl/tsan_mman.cc	/^void *internal_alloc(MBlockType typ, uptr sz) {$/;"	f	namespace:__tsan
internal_alloc_cache	rtl/tsan_rtl.h	/^  InternalAllocatorCache internal_alloc_cache;$/;"	m	struct:__tsan::ThreadState
internal_deadlock_detector	rtl/tsan_rtl.h	/^  InternalDeadlockDetector internal_deadlock_detector;$/;"	m	struct:__tsan::ThreadState
internal_free	go/tsan_go.cc	/^void internal_free(void *p) {$/;"	f	namespace:__tsan
internal_free	rtl/tsan_mman.cc	/^void internal_free(void *p) {$/;"	f	namespace:__tsan
internal_join_thread	go/tsan_go.cc	/^void internal_join_thread(void *th) {$/;"	f	namespace:__tsan
internal_join_thread	rtl/tsan_interceptors.cc	/^void internal_join_thread(void *th) {$/;"	f	namespace:__tsan
internal_start_thread	go/tsan_go.cc	/^void *internal_start_thread(void(*func)(void*), void *arg) {$/;"	f	namespace:__tsan
internal_start_thread	rtl/tsan_interceptors.cc	/^void *internal_start_thread(void(*func)(void *arg), void *arg) {$/;"	f	namespace:__tsan
invoke_free_hook	rtl/tsan_mman.cc	/^void invoke_free_hook(void *ptr) {$/;"	f	namespace:__tsan
invoke_malloc_hook	rtl/tsan_mman.cc	/^void invoke_malloc_hook(void *ptr, uptr size) {$/;"	f	namespace:__tsan
io_sync	rtl/tsan_flags.h	/^  int io_sync;$/;"	m	struct:__tsan::Flags
is_broken	rtl/tsan_sync.h	/^  bool is_broken;$/;"	m	struct:__tsan::SyncVar
is_dead	rtl/tsan_rtl.h	/^  bool is_dead;$/;"	m	struct:__tsan::ThreadState
is_freeing	rtl/tsan_rtl.h	/^  bool is_freeing;$/;"	m	struct:__tsan::ThreadState
is_linker_init	rtl/tsan_sync.h	/^  bool is_linker_init;$/;"	m	struct:__tsan::SyncVar
is_racy_addr	rtl/tsan_rtl_report.cc	/^ReportThread* is_racy_addr(uptr addr)$/;"	f	namespace:__tsan
is_recursive	rtl/tsan_sync.h	/^  bool is_recursive;$/;"	m	struct:__tsan::SyncVar
is_rw	rtl/tsan_sync.h	/^  bool is_rw;$/;"	m	struct:__tsan::SyncVar
is_sync_signal	rtl/tsan_interceptors.cc	/^static bool is_sync_signal(SignalContext *sctx, int sig) {$/;"	f	file:
is_vptr_access	rtl/tsan_rtl.h	/^  bool is_vptr_access;$/;"	m	struct:__tsan::ThreadState
iter_	rtl/tsan_mutex.cc	/^  int iter_;$/;"	m	class:__tsan::Backoff	file:
jctx	rtl/tsan_interface_java.cc	/^static JavaContext *jctx;$/;"	m	namespace:__tsan	file:
jctx_buf	rtl/tsan_interface_java.cc	/^static u64 jctx_buf[sizeof(JavaContext) \/ sizeof(u64) + 1];$/;"	m	namespace:__tsan	file:
jin	mytest/simple_race.cc	/^int jin=0;$/;"	v
jmp_bufs	rtl/tsan_rtl.h	/^  Vector<JmpBuf> jmp_bufs;$/;"	m	struct:__tsan::ThreadState
jptr	rtl/tsan_interface_java.h	/^typedef unsigned long jptr;  \/\/ NOLINT$/;"	t
kActiveSpinCnt	rtl/tsan_mutex.cc	/^  static const int kActiveSpinCnt = 20;$/;"	m	class:__tsan::Backoff	file:
kActiveSpinIters	rtl/tsan_mutex.cc	/^  static const int kActiveSpinIters = 10;$/;"	m	class:__tsan::Backoff	file:
kAppMemMsk	rtl/tsan_platform.h	/^const uptr kAppMemMsk     = 0x7c0000000000ull;$/;"	m	namespace:__tsan
kAppMemXor	rtl/tsan_platform.h	/^const uptr kAppMemXor     = 0x020000000000ull;$/;"	m	namespace:__tsan
kAtomicBit	rtl/tsan_rtl.h	/^  static const u64 kAtomicBit   = 1ull << kAtomicShift;$/;"	m	class:__tsan::Shadow
kAtomicShift	rtl/tsan_rtl.h	/^  static const u64 kAtomicShift = 6 + kClkBits;$/;"	m	class:__tsan::Shadow
kClkBits	rtl/tsan_defs.h	/^const int kClkBits = 42;$/;"	m	namespace:__tsan
kClockCount	rtl/tsan_clock.h	/^  static const uptr kClockCount = kSize \/ sizeof(ClockElem);$/;"	m	struct:__tsan::ClockBlock
kClocks	tests/unit/tsan_clock_test.cc	/^const int kClocks = 4;$/;"	m	namespace:__tsan	file:
kCollectHistory	rtl/tsan_defs.h	/^const bool kCollectHistory = false;$/;"	m	namespace:__tsan
kCollectHistory	rtl/tsan_defs.h	/^const bool kCollectHistory = true;$/;"	m	namespace:__tsan
kCollectStats	rtl/tsan_defs.h	/^const bool kCollectStats = false;$/;"	m	namespace:__tsan
kCollectStats	rtl/tsan_defs.h	/^const bool kCollectStats = true;$/;"	m	namespace:__tsan
kCppMode	rtl/tsan_defs.h	/^const bool kCppMode = false;$/;"	m	namespace:__tsan
kDefaultAlignment	rtl/tsan_mman.h	/^const uptr kDefaultAlignment = 16;$/;"	m	namespace:__tsan
kExternalPCBit	rtl/tsan_symbolize.cc	/^const uptr kExternalPCBit = 1ULL << 60;$/;"	m	namespace:__tsan	file:
kFlagBlock	rtl/tsan_sync.h	/^  static const u32 kFlagBlock = 1 << 30;$/;"	m	class:__tsan::MetaMap
kFlagMask	rtl/tsan_sync.h	/^  static const u32 kFlagMask  = 3 << 30;$/;"	m	class:__tsan::MetaMap
kFlagSync	rtl/tsan_sync.h	/^  static const u32 kFlagSync  = 2 << 30;$/;"	m	class:__tsan::MetaMap
kFreedBit	rtl/tsan_rtl.h	/^  static const u64 kFreedBit = 1ull << 63;$/;"	m	class:__tsan::FastState
kGoMode	rtl/tsan_defs.h	/^const bool kGoMode = true;$/;"	m	namespace:__tsan
kHeapAlignment	rtl/tsan_interface_java.cc	/^const jptr kHeapAlignment = 8;$/;"	v
kHeapMemBeg	rtl/tsan_platform.h	/^const uptr kHeapMemBeg    = 0x7d0000000000ull;$/;"	m	namespace:__tsan
kHeapMemEnd	rtl/tsan_platform.h	/^const uptr kHeapMemEnd    = 0x7e0000000000ull;$/;"	m	namespace:__tsan
kHiAppMemBeg	rtl/tsan_platform.h	/^const uptr kHiAppMemBeg   = 0x7e8000000000ull;$/;"	m	namespace:__tsan
kHiAppMemEnd	rtl/tsan_platform.h	/^const uptr kHiAppMemEnd   = 0x800000000000ull;$/;"	m	namespace:__tsan
kHistoryMask	rtl/tsan_rtl.h	/^  static const u64 kHistoryMask = 7;$/;"	m	class:__tsan::FastState
kHistoryShift	rtl/tsan_rtl.h	/^  static const u64 kHistoryShift = kClkBits;$/;"	m	class:__tsan::FastState
kIgnoreBit	rtl/tsan_rtl.h	/^  static const u64 kIgnoreBit = 1ull << 63;$/;"	m	class:__tsan::FastState
kInvalidTid	rtl/tsan_clock.cc	/^const unsigned kInvalidTid = (unsigned)-1;$/;"	m	namespace:__tsan	file:
kInvalidTid	rtl/tsan_sync.h	/^  static const int kInvalidTid = -1;$/;"	m	struct:__tsan::SyncVar
kIters	tests/unit/tsan_mutex_test.cc	/^const int kIters = 16*1024;$/;"	m	namespace:__tsan	file:
kIters	tests/unit/tsan_mutex_test.cc	/^const int kIters = 64*1024;$/;"	m	namespace:__tsan	file:
kLoAppMemBeg	rtl/tsan_platform.h	/^const uptr kLoAppMemBeg   = 0x000000001000ull;$/;"	m	namespace:__tsan
kLoAppMemEnd	rtl/tsan_platform.h	/^const uptr kLoAppMemEnd   = 0x010000000000ull;$/;"	m	namespace:__tsan
kMainThreadId	rtl/tsan_report.cc	/^const int kMainThreadId = 1;$/;"	m	namespace:__tsan	file:
kMaxDescLen	rtl/tsan_interface_ann.cc	/^static const int kMaxDescLen = 128;$/;"	m	namespace:__tsan	file:
kMaxSize	rtl/tsan_ignoreset.cc	/^const uptr IgnoreSet::kMaxSize;$/;"	m	class:__tsan::IgnoreSet	file:
kMaxSize	rtl/tsan_ignoreset.h	/^  static const uptr kMaxSize = 16;$/;"	m	class:__tsan::IgnoreSet
kMaxSize	rtl/tsan_mutexset.cc	/^const uptr MutexSet::kMaxSize;$/;"	m	class:__tsan::MutexSet	file:
kMaxSize	rtl/tsan_mutexset.h	/^  static const uptr kMaxSize = 16;$/;"	m	class:__tsan::MutexSet
kMaxTid	rtl/tsan_defs.h	/^const unsigned kMaxTid = 1 << kTidBits;$/;"	m	namespace:__tsan
kMaxTidInClock	rtl/tsan_defs.h	/^const unsigned kMaxTidInClock = kMaxTid * 2;  \/\/ This includes msb 'freed' bit.$/;"	m	namespace:__tsan
kMaxTidReuse	rtl/tsan_defs.h	/^const unsigned kMaxTidReuse = (1 << (64 - kClkBits)) - 1;$/;"	m	namespace:__tsan
kMetaShadowBeg	rtl/tsan_platform.h	/^const uptr kMetaShadowBeg = 0x300000000000ull;$/;"	m	namespace:__tsan
kMetaShadowCell	rtl/tsan_defs.h	/^const uptr kMetaShadowCell = 8;$/;"	m	namespace:__tsan
kMetaShadowEnd	rtl/tsan_platform.h	/^const uptr kMetaShadowEnd = 0x400000000000ull;$/;"	m	namespace:__tsan
kMetaShadowSize	rtl/tsan_defs.h	/^const uptr kMetaShadowSize = 4;$/;"	m	namespace:__tsan
kNumIter	benchmarks/mini_bench_local.cc	/^const int kNumIter = 1000;$/;"	v
kNumIter	benchmarks/mini_bench_shared.cc	/^const int kNumIter = 1000;$/;"	v
kNumMutexes	benchmarks/vts_many_threads_bench.cc	/^const int kNumMutexes = 1024;$/;"	v
kPageSize	rtl/tsan_platform_linux.cc	/^const uptr kPageSize = 4096;$/;"	m	namespace:__tsan	file:
kReadBit	rtl/tsan_rtl.h	/^  static const u64 kReadBit     = 1ull << kReadShift;$/;"	m	class:__tsan::Shadow
kReadLock	rtl/tsan_mutex.cc	/^const uptr kReadLock = 2;$/;"	m	namespace:__tsan	file:
kReadShift	rtl/tsan_rtl.h	/^  static const u64 kReadShift   = 5 + kClkBits;$/;"	m	class:__tsan::Shadow
kRepeat	tests/rtl/tsan_bench.cc	/^const int kRepeat = 2*1024*1024;$/;"	v
kShadowBeg	rtl/tsan_platform.h	/^const uptr kShadowBeg     = 0x020000000000ull;$/;"	m	namespace:__tsan
kShadowCell	rtl/tsan_defs.h	/^const uptr kShadowCell = 8;$/;"	m	namespace:__tsan
kShadowCnt	rtl/tsan_defs.h	/^const uptr kShadowCnt = 4;$/;"	m	namespace:__tsan
kShadowCnt	rtl/tsan_defs.h	/^const uptr kShadowCnt = TSAN_SHADOW_COUNT;$/;"	m	namespace:__tsan
kShadowEnd	rtl/tsan_platform.h	/^const uptr kShadowEnd     = 0x100000000000ull;$/;"	m	namespace:__tsan
kShadowMultiplier	rtl/tsan_defs.h	/^const uptr kShadowMultiplier = kShadowSize * kShadowCnt \/ kShadowCell;$/;"	m	namespace:__tsan
kShadowRodata	rtl/tsan_rtl.h	/^const u64 kShadowRodata = (u64)-1;  \/\/ .rodata shadow marker$/;"	m	namespace:__tsan
kShadowSize	rtl/tsan_defs.h	/^const uptr kShadowSize = 8;$/;"	m	namespace:__tsan
kShadowStackSize	rtl/tsan_defs.h	/^const uptr kShadowStackSize = 64 * 1024;$/;"	m	namespace:__tsan
kSigCount	rtl/tsan_interceptors.cc	/^const int kSigCount = 65;$/;"	v
kSize	rtl/tsan_clock.h	/^  static const uptr kSize = 512;$/;"	m	struct:__tsan::ClockBlock
kSize	rtl/tsan_dense_alloc.h	/^  static const uptr kSize = 128;$/;"	m	class:__tsan::DenseSlabAllocCache
kSize	tests/rtl/tsan_bench.cc	/^const int kSize = 128;$/;"	v
kSize	tests/unit/tsan_mutex_test.cc	/^  static const int kSize = 64;$/;"	m	class:__tsan::TestData	file:
kSizeLog1	rtl/tsan_rtl.h	/^const int kSizeLog1 = 0;$/;"	m	namespace:__tsan
kSizeLog2	rtl/tsan_rtl.h	/^const int kSizeLog2 = 1;$/;"	m	namespace:__tsan
kSizeLog4	rtl/tsan_rtl.h	/^const int kSizeLog4 = 2;$/;"	m	namespace:__tsan
kSizeLog8	rtl/tsan_rtl.h	/^const int kSizeLog8 = 3;$/;"	m	namespace:__tsan
kTableSize	rtl/tsan_clock.h	/^  static const uptr kTableSize = kSize \/ sizeof(u32);$/;"	m	struct:__tsan::ClockBlock
kTableSize	rtl/tsan_fd.cc	/^const int kTableSize = kTableSizeL1 * kTableSizeL2;$/;"	m	namespace:__tsan	file:
kTableSizeL1	rtl/tsan_fd.cc	/^const int kTableSizeL1 = 1024;$/;"	m	namespace:__tsan	file:
kTableSizeL2	rtl/tsan_fd.cc	/^const int kTableSizeL2 = 1024;$/;"	m	namespace:__tsan	file:
kThreadBufSize	rtl/tsan_report.cc	/^const int kThreadBufSize = 32;$/;"	m	namespace:__tsan	file:
kThreadQuarantineSize	rtl/tsan_rtl.cc	/^static const u32 kThreadQuarantineSize = 16;$/;"	m	namespace:__tsan	file:
kThreadQuarantineSize	rtl/tsan_rtl.cc	/^static const u32 kThreadQuarantineSize = 64;$/;"	m	namespace:__tsan	file:
kThreads	tests/unit/tsan_clock_test.cc	/^const int kThreads = 4;$/;"	m	namespace:__tsan	file:
kThreads	tests/unit/tsan_mutex_test.cc	/^const int kThreads = 8;$/;"	m	namespace:__tsan	file:
kTidBits	rtl/tsan_defs.h	/^const int kTidBits = 13;$/;"	m	namespace:__tsan
kTidShift	rtl/tsan_rtl.h	/^  static const int kTidShift = 64 - kTidBits - 1;$/;"	m	class:__tsan::FastState
kTotalTraceSize	rtl/tsan_platform.h	/^const uptr kTotalTraceSize = (kTraceSize * sizeof(Event) + sizeof(Trace)$/;"	m	namespace:__tsan
kTraceMemBeg	rtl/tsan_platform.h	/^const uptr kTraceMemBeg   = 0x600000000000ull;$/;"	m	namespace:__tsan
kTraceMemEnd	rtl/tsan_platform.h	/^const uptr kTraceMemEnd   = 0x620000000000ull;$/;"	m	namespace:__tsan
kTracePartSize	rtl/tsan_trace.h	/^const int kTracePartSize = 1 << kTracePartSizeBits;$/;"	m	namespace:__tsan
kTracePartSizeBits	rtl/tsan_trace.h	/^const int kTracePartSizeBits = 14;$/;"	m	namespace:__tsan
kTraceParts	rtl/tsan_trace.h	/^const int kTraceParts = 4 * 1024 * 1024 \/ kTracePartSize;$/;"	m	namespace:__tsan
kTraceSize	rtl/tsan_trace.h	/^const int kTraceSize = kTracePartSize * kTraceParts;$/;"	m	namespace:__tsan
kTsanOptionsEnv	rtl/tsan_defs.h	/^const char *const kTsanOptionsEnv = "GORACE";$/;"	m	namespace:__tsan
kUnlocked	rtl/tsan_mutex.cc	/^const uptr kUnlocked = 0;$/;"	m	namespace:__tsan	file:
kWriteLock	rtl/tsan_mutex.cc	/^const uptr kWriteLock = 1;$/;"	m	namespace:__tsan	file:
kWriteRate	tests/unit/tsan_mutex_test.cc	/^const int kWriteRate = 1024;$/;"	m	namespace:__tsan	file:
key	tests/rtl/tsan_posix.cc	/^  pthread_key_t key;$/;"	m	struct:thread_key	file:
last_	rtl/tsan_vector.h	/^  T *last_;$/;"	m	class:__tsan::Vector
last_lock	rtl/tsan_sync.h	/^  u64 last_lock;$/;"	m	struct:__tsan::SyncVar
last_sleep_clock	rtl/tsan_rtl.h	/^  ThreadClock last_sleep_clock;$/;"	m	struct:__tsan::ThreadState
last_sleep_stack_id	rtl/tsan_rtl.h	/^  u32 last_sleep_stack_id;$/;"	m	struct:__tsan::ThreadState
last_symbolize_time_ns	rtl/tsan_rtl.h	/^  atomic_uint64_t last_symbolize_time_ns;$/;"	m	struct:__tsan::Context
len	benchmarks/mini_bench_local.cc	/^int len;$/;"	v
len	benchmarks/mini_bench_shared.cc	/^int len;$/;"	v
libignore	rtl/tsan_interceptors.cc	/^static LibIgnore *libignore() {$/;"	f	namespace:__tsan
libignore_placeholder	rtl/tsan_interceptors.cc	/^static ALIGNED(64) char libignore_placeholder[sizeof(LibIgnore)];$/;"	m	namespace:__tsan	file:
line	go/tsan_go.cc	/^  uptr line;$/;"	m	struct:__tsan::SymbolizeContext	file:
line	rtl/tsan_interface_ann.cc	/^  int line;$/;"	m	struct:__tsan::ExpectRace	file:
lo	rtl/tsan_md5.cc	/^  MD5_u32plus lo, hi;$/;"	m	struct:__tsan::__anon5	file:
loc	tests/rtl/tsan_test_util.h	/^  void *loc() const { return loc_; }$/;"	f	class:MemLoc
loc_	tests/rtl/tsan_test_util.h	/^  void *const loc_;$/;"	m	class:MemLoc
local_thread	tests/rtl/tsan_posix.cc	/^static void *local_thread(void *p) {$/;"	f	file:
local_var	tests/rtl/tsan_posix.cc	/^static __thread int local_var;$/;"	v	file:
locked_	rtl/tsan_mutex.h	/^  u64 locked_[MutexTypeCount];$/;"	m	class:__tsan::InternalDeadlockDetector
locs	rtl/tsan_report.h	/^  Vector<ReportLocation*> locs;$/;"	m	class:__tsan::ReportDesc
long_t	rtl/tsan_interceptors.cc	/^typedef long long_t;  \/\/ NOLINT$/;"	t	file:
m	rtl/tsan_interceptors.cc	/^  void *m;$/;"	m	struct:CondMutexUnlockCtx	file:
m	tests/rtl/tsan_posix.cc	/^  pthread_mutex_t m;$/;"	m	struct:CondContext	file:
m128	rtl/tsan_rtl.cc	/^typedef __m128i m128;$/;"	t	file:
m_	benchmarks/vts_many_threads_bench.cc	/^  pthread_mutex_t m_;$/;"	m	class:Mutex	file:
main	benchmarks/mini_bench_local.cc	/^int main(int argc, char **argv) {$/;"	f
main	benchmarks/mini_bench_shared.cc	/^int main(int argc, char **argv) {$/;"	f
main	benchmarks/start_many_threads.cc	/^int main(int argc, char **argv) {$/;"	f
main	benchmarks/vts_many_threads_bench.cc	/^int main(int argc, char **argv) {$/;"	f
main	go/test.c	/^int main(void) {$/;"	f
main	mytest/four_races.c	/^int main() {$/;"	f
main	mytest/simple_race.cc	/^int main() {$/;"	f
main	tests/rtl/tsan_test.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/rtl/tsan_test_util_linux.cc	/^  bool main;$/;"	m	struct:ScopedThread::Impl	file:
main	tests/unit/tsan_unit_test_main.cc	/^int main(int argc, char **argv) {$/;"	f
main_thr	go/tsan_go.cc	/^static ThreadState *main_thr;$/;"	v	file:
main_threads_ready	benchmarks/vts_many_threads_bench.cc	/^pthread_barrier_t all_threads_ready, main_threads_ready;$/;"	v
mangled_sp	rtl/tsan_rtl.h	/^  uptr mangled_sp;$/;"	m	struct:__tsan::JmpBuf
map_	rtl/tsan_dense_alloc.h	/^  T *map_[kL1Size];$/;"	m	class:__tsan::DenseSlabAlloc
mat	mytest/simple_race.cc	/^int mat=0;$/;"	v
max	rtl/tsan_defs.h	/^T max(T a, T b) {$/;"	f	namespace:__tsan
md5_hash	rtl/tsan_md5.cc	/^MD5Hash md5_hash(const void *data, uptr size) {$/;"	f	namespace:__tsan
memory_limit_mb	rtl/tsan_flags.h	/^  int memory_limit_mb;$/;"	m	struct:__tsan::Flags
metamap	rtl/tsan_rtl.h	/^  MetaMap metamap;$/;"	m	struct:__tsan::Context
min	rtl/tsan_defs.h	/^T min(T a, T b) {$/;"	f	namespace:__tsan
mo_acq_rel	rtl/tsan_interface_atomic.cc	/^  mo_acq_rel,$/;"	e	enum:__anon2	file:
mo_acquire	rtl/tsan_interface_atomic.cc	/^  mo_acquire,$/;"	e	enum:__anon2	file:
mo_consume	rtl/tsan_interface_atomic.cc	/^  mo_consume,$/;"	e	enum:__anon2	file:
mo_relaxed	rtl/tsan_interface_atomic.cc	/^  mo_relaxed,$/;"	e	enum:__anon2	file:
mo_release	rtl/tsan_interface_atomic.cc	/^  mo_release,$/;"	e	enum:__anon2	file:
mo_seq_cst	rtl/tsan_interface_atomic.cc	/^  mo_seq_cst$/;"	e	enum:__anon2	file:
mop_ignore_set	rtl/tsan_rtl.h	/^  IgnoreSet mop_ignore_set;$/;"	m	struct:__tsan::ThreadState
mops	rtl/tsan_report.h	/^  Vector<ReportMop*> mops;$/;"	m	class:__tsan::ReportDesc
morder	rtl/tsan_interface_atomic.cc	/^} morder;$/;"	t	typeref:enum:__anon2	file:
mset	rtl/tsan_report.h	/^  Vector<ReportMopMutex> mset;$/;"	m	struct:__tsan::ReportMop
mset	rtl/tsan_rtl.h	/^  MutexSet mset;$/;"	m	struct:__tsan::ThreadState
mset0	rtl/tsan_trace.h	/^  MutexSet   mset0;$/;"	m	struct:__tsan::TraceHeader
mtx	rtl/tsan_interface_ann.cc	/^  Mutex mtx;$/;"	m	struct:__tsan::DynamicAnnContext	file:
mtx	rtl/tsan_sync.h	/^  Mutex mtx;$/;"	m	struct:__tsan::SyncVar
mtx	rtl/tsan_trace.h	/^  Mutex mtx;$/;"	m	struct:__tsan::Trace
mtx	tests/rtl/tsan_posix.cc	/^  pthread_mutex_t *mtx;$/;"	m	struct:thread_key	file:
mtx_	rtl/tsan_dense_alloc.h	/^  SpinMutex mtx_;$/;"	m	class:__tsan::DenseSlabAlloc
mtx_	tests/rtl/tsan_test_util.h	/^  void *mtx_[128];$/;"	m	class:Mutex
mtx_	tests/unit/tsan_mutex_test.cc	/^  MutexType *mtx_;$/;"	m	class:__tsan::TestData	file:
mutex128	rtl/tsan_interface_atomic.cc	/^static StaticSpinMutex mutex128;$/;"	v	file:
mutex_map	dd/dd_rtl.h	/^  MutexHashMap mutex_map;$/;"	m	struct:__dsan::Context
mutexes	benchmarks/vts_many_threads_bench.cc	/^Mutex mutexes[kNumMutexes];$/;"	v
mutexes	rtl/tsan_report.h	/^  Vector<ReportMutex*> mutexes;$/;"	m	class:__tsan::ReportDesc
my_siginfo_t	rtl/tsan_interceptors.cc	/^struct my_siginfo_t {$/;"	s	file:
myspinlock	mytest/simple_race.cc	/^pthread_spinlock_t myspinlock;$/;"	v
n_iterations	benchmarks/vts_many_threads_bench.cc	/^int n_threads, n_iterations;$/;"	v
n_threads	benchmarks/vts_many_threads_bench.cc	/^int n_threads, n_iterations;$/;"	v
name	rtl/tsan_report.h	/^  char *name;$/;"	m	struct:__tsan::ReportThread
next	rtl/tsan_interface_ann.cc	/^  ExpectRace *next;$/;"	m	struct:__tsan::ExpectRace	file:
next	rtl/tsan_report.h	/^  ReportStack *next;$/;"	m	struct:__tsan::ReportStack
next	rtl/tsan_report.h	/^  ReportThread *next;$/;"	m	struct:__tsan::ReportThread
next	rtl/tsan_sync.h	/^  u32 next;  \/\/ in MetaMap$/;"	m	struct:__tsan::SyncVar
nmissed_expected	rtl/tsan_rtl.h	/^  int nmissed_expected;$/;"	m	struct:__tsan::Context
noinstr	tests/rtl/tsan_bench.cc	/^void noinstr(void *p) {}$/;"	f
nomalloc	rtl/tsan_rtl.h	/^  int nomalloc;$/;"	m	struct:__tsan::ThreadState
nothrow_t	rtl/tsan_interceptors.cc	/^struct nothrow_t {};$/;"	s	namespace:std	file:
nreported	rtl/tsan_rtl.h	/^  int nreported;$/;"	m	struct:__tsan::Context
nsec	rtl/tsan_report.h	/^  u64 nsec;$/;"	m	struct:__tsan::ReportThread
off	go/tsan_go.cc	/^  uptr off;$/;"	m	struct:__tsan::SymbolizeContext	file:
on_exit_wrapper	rtl/tsan_interceptors.cc	/^static void on_exit_wrapper(int status, void *arg) {$/;"	f	file:
opaque	rtl/tsan_interceptors.cc	/^  u64 opaque[128 \/ sizeof(u64)];$/;"	m	struct:my_siginfo_t	file:
opaque	rtl/tsan_interceptors.cc	/^  u64 opaque[936 \/ sizeof(u64) + 1];$/;"	m	struct:ucontext_t	file:
operator =	rtl/tsan_mutexset.h	/^  void operator=(const MutexSet &other) {$/;"	f	class:__tsan::MutexSet
operator ==	rtl/tsan_rtl.cc	/^bool MD5Hash::operator==(const MD5Hash &other) const {$/;"	f	class:__tsan::MD5Hash
operator ==	rtl/tsan_rtl.h	/^  bool operator==(const RacyStacks &other) const {$/;"	f	struct:__tsan::RacyStacks
operator []	rtl/tsan_vector.h	/^  T &operator[](uptr i) {$/;"	f	class:__tsan::Vector
operator []	rtl/tsan_vector.h	/^  const T &operator[](uptr i) const {$/;"	f	class:__tsan::Vector
operator delete	rtl/tsan_interceptors.cc	/^void operator delete(void *ptr) throw() {$/;"	f
operator delete	rtl/tsan_interceptors.cc	/^void operator delete(void *ptr, std::nothrow_t const&) {$/;"	f
operator delete[]	rtl/tsan_interceptors.cc	/^void operator delete[](void *ptr) throw() {$/;"	f
operator delete[]	rtl/tsan_interceptors.cc	/^void operator delete[](void *ptr, std::nothrow_t const&) {$/;"	f
operator new	rtl/tsan_interceptors.cc	/^void *operator new(__sanitizer::uptr size) {$/;"	f
operator new	rtl/tsan_interceptors.cc	/^void *operator new(__sanitizer::uptr size, std::nothrow_t const&) {$/;"	f
operator new[]	rtl/tsan_interceptors.cc	/^void *operator new[](__sanitizer::uptr size) {$/;"	f
operator new[]	rtl/tsan_interceptors.cc	/^void *operator new[](__sanitizer::uptr size, std::nothrow_t const&) {$/;"	f
options1	tests/unit/tsan_flags_test.cc	/^static const char *options1 =$/;"	m	namespace:__tsan	file:
options2	tests/unit/tsan_flags_test.cc	/^static const char *options2 =$/;"	m	namespace:__tsan	file:
owner_tid	rtl/tsan_sync.h	/^  int owner_tid;  \/\/ Set only by exclusive owners.$/;"	m	struct:__tsan::SyncVar
pad_	tests/unit/tsan_mutex_test.cc	/^  char pad_[kCacheLineSize];$/;"	m	class:__tsan::TestData	file:
param	rtl/tsan_interceptors.cc	/^  void *param;$/;"	m	struct:ThreadParam	file:
parent_tid	rtl/tsan_report.h	/^  int parent_tid;$/;"	m	struct:__tsan::ReportThread
pc	go/tsan_go.cc	/^  uptr pc;$/;"	m	struct:__tsan::SymbolizeContext	file:
pc	rtl/tsan_interceptors.cc	/^  const uptr pc;$/;"	m	struct:TsanInterceptorContext	file:
pc	rtl/tsan_interceptors.cc	/^  uptr pc;$/;"	m	struct:CondMutexUnlockCtx	file:
pc	rtl/tsan_rtl.h	/^  uptr pc;$/;"	m	struct:__tsan::FiredSuppression
pc	rtl/tsan_rtl_mutex.cc	/^  uptr pc;$/;"	m	struct:__tsan::Callback	file:
pc	rtl/tsan_rtl_thread.cc	/^  uptr pc;$/;"	m	struct:__tsan::OnCreatedArgs	file:
pc_	rtl/tsan_interceptors.cc	/^  const uptr pc_;$/;"	m	class:ScopedInterceptor	file:
pending_signals	rtl/tsan_interceptors.cc	/^  SignalDesc pending_signals[kSigCount];$/;"	m	struct:__tsan::SignalContext	file:
pid	rtl/tsan_report.h	/^  uptr pid;$/;"	m	struct:__tsan::ReportThread
pos	rtl/tsan_dense_alloc.h	/^  uptr pos;$/;"	m	class:__tsan::DenseSlabAllocCache
prev	rtl/tsan_interface_ann.cc	/^  ExpectRace *prev;$/;"	m	struct:__tsan::ExpectRace	file:
print_benign	rtl/tsan_flags.h	/^  bool print_benign;$/;"	m	struct:__tsan::Flags
profile_memory	rtl/tsan_flags.h	/^  const char *profile_memory;$/;"	m	struct:__tsan::Flags
ptr	tests/rtl/tsan_test_util_linux.cc	/^  void *ptr;$/;"	m	struct:Event	file:
race_addr	rtl/tsan_rtl_report.cc	/^uptr race_addr = 0;$/;"	m	namespace:__tsan	file:
race_addrs	rtl/tsan_rtl_report.cc	/^IntrusiveList<ReportThread> race_addrs;$/;"	m	namespace:__tsan	file:
racy_addresses	rtl/tsan_rtl.h	/^  Vector<RacyAddress> racy_addresses;$/;"	m	struct:__tsan::Context
racy_shadow_addr	rtl/tsan_rtl.h	/^  u64 *racy_shadow_addr;$/;"	m	struct:__tsan::ThreadState
racy_stacks	rtl/tsan_rtl.h	/^  Vector<RacyStacks> racy_stacks;$/;"	m	struct:__tsan::Context
racy_state	rtl/tsan_rtl.h	/^  u64 racy_state[2];$/;"	m	struct:__tsan::ThreadState
raw	rtl/tsan_rtl.h	/^  u64 raw() const {$/;"	f	class:__tsan::FastState
rc	rtl/tsan_fd.cc	/^  atomic_uint64_t rc;$/;"	m	struct:__tsan::FdSync	file:
read_clock	rtl/tsan_sync.h	/^  SyncClock read_clock;  \/\/ Used for rw mutexes only.$/;"	m	struct:__tsan::SyncVar
read_mutex_thread	tests/unit/tsan_mutex_test.cc	/^static void *read_mutex_thread(void *param) {$/;"	f	namespace:__tsan
recursion	rtl/tsan_sync.h	/^  int recursion;$/;"	m	struct:__tsan::SyncVar
ref	rtl/tsan_fd.cc	/^static FdSync *ref(FdSync *s) {$/;"	f	namespace:__tsan
release	rtl/tsan_clock.cc	/^void ThreadClock::release(ClockCache *c, SyncClock *dst) const {$/;"	f	class:__tsan::ThreadClock
release	tests/unit/tsan_clock_test.cc	/^  void release(SimpleSyncClock *dst) const {$/;"	f	struct:__tsan::SimpleThreadClock
rep_	rtl/tsan_rtl.h	/^  ReportDesc *rep_;$/;"	m	class:__tsan::ScopedReport
report_atomic_races	rtl/tsan_flags.h	/^  bool report_atomic_races;$/;"	m	struct:__tsan::Flags
report_bugs	rtl/tsan_flags.h	/^  bool report_bugs;$/;"	m	struct:__tsan::Flags
report_destroy_locked	rtl/tsan_flags.h	/^  bool report_destroy_locked;$/;"	m	struct:__tsan::Flags
report_mtx	rtl/tsan_rtl.h	/^  Mutex report_mtx;$/;"	m	struct:__tsan::Context
report_mutex	dd/dd_rtl.h	/^  BlockingMutex report_mutex;$/;"	m	struct:__dsan::Context
report_mutex_bugs	rtl/tsan_flags.h	/^  bool report_mutex_bugs;$/;"	m	struct:__tsan::Flags
report_signal_unsafe	rtl/tsan_flags.h	/^  bool report_signal_unsafe;$/;"	m	struct:__tsan::Flags
report_thread_leaks	rtl/tsan_flags.h	/^  bool report_thread_leaks;$/;"	m	struct:__tsan::Flags
report_type	tests/rtl/tsan_test_util_linux.cc	/^  ReportType report_type;$/;"	m	struct:Event	file:
res	go/tsan_go.cc	/^  uptr res;$/;"	m	struct:__tsan::SymbolizeContext	file:
res	tests/rtl/tsan_test_util_linux.cc	/^  bool res;$/;"	m	struct:Event	file:
reused	rtl/tsan_clock.h	/^  u64 reused : 64 - kClkBits;$/;"	m	struct:__tsan::ClockElem
rtl_generic_sighandler	rtl/tsan_interceptors.cc	/^void ALWAYS_INLINE rtl_generic_sighandler(bool sigact, int sig,$/;"	f
rtl_sigaction	rtl/tsan_interceptors.cc	/^static void rtl_sigaction(int sig, my_siginfo_t *info, void *ctx) {$/;"	f	file:
rtl_sighandler	rtl/tsan_interceptors.cc	/^static void rtl_sighandler(int sig) {$/;"	f	file:
run_tests	tests/rtl/tsan_test.cc	/^int run_tests(int argc, char **argv) {$/;"	f
running	rtl/tsan_report.h	/^  bool running;$/;"	m	struct:__tsan::ReportThread
running_on_valgrind	rtl/tsan_flags.h	/^  bool running_on_valgrind;$/;"	m	struct:__tsan::Flags
sa_flags	rtl/tsan_interceptors.cc	/^  int sa_flags;$/;"	m	struct:sigaction_t	file:
sa_handler	rtl/tsan_interceptors.cc	/^    sighandler_t sa_handler;$/;"	m	union:sigaction_t::__anon1	file:
sa_handler	rtl/tsan_platform_linux.cc	52;"	d	file:
sa_mask	rtl/tsan_interceptors.cc	/^  __sanitizer_sigset_t sa_mask;$/;"	m	struct:sigaction_t	file:
sa_restorer	rtl/tsan_interceptors.cc	/^  void (*sa_restorer)();$/;"	m	struct:sigaction_t	file:
sa_sigaction	rtl/tsan_interceptors.cc	/^    void (*sa_sigaction)(int sig, my_siginfo_t *siginfo, void *uctx);$/;"	m	union:sigaction_t::__anon1	file:
sa_sigaction	rtl/tsan_platform_linux.cc	56;"	d	file:
sec	rtl/tsan_report.h	/^  u64 sec;$/;"	m	struct:__tsan::ReportThread
send	tests/rtl/tsan_test_util_linux.cc	/^void ScopedThread::Impl::send(Event *e) {$/;"	f	class:ScopedThread::Impl
seq_	rtl/tsan_mutex.h	/^  u64 seq_;$/;"	m	class:__tsan::InternalDeadlockDetector
set	rtl/tsan_clock.cc	/^void ThreadClock::set(unsigned tid, u64 v) {$/;"	f	class:__tsan::ThreadClock
setjmp	rtl/tsan_rtl_amd64.S	/^setjmp:$/;"	l
setup_at_exit_wrapper	rtl/tsan_interceptors.cc	/^static int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),$/;"	f	file:
shadow_stack	rtl/tsan_rtl.h	/^  uptr *shadow_stack;$/;"	m	struct:__tsan::ThreadState
shadow_stack	rtl/tsan_trace.h	/^  uptr shadow_stack[kShadowStackSize];$/;"	m	struct:__tsan::Trace
shadow_stack_end	rtl/tsan_rtl.h	/^  uptr *shadow_stack_end;$/;"	m	struct:__tsan::ThreadState
shadow_stack_pos	rtl/tsan_rtl.h	/^  uptr *shadow_stack_pos;$/;"	m	struct:__tsan::JmpBuf
shadow_stack_pos	rtl/tsan_rtl.h	/^  uptr *shadow_stack_pos;$/;"	m	struct:__tsan::ThreadState
sigaction	rtl/tsan_interceptors.cc	/^  bool sigaction;$/;"	m	struct:__tsan::SignalDesc	file:
sigaction_t	rtl/tsan_interceptors.cc	/^struct sigaction_t {$/;"	s	file:
sigactions	rtl/tsan_interceptors.cc	/^static sigaction_t sigactions[kSigCount];$/;"	v	file:
sighandler_t	rtl/tsan_interceptors.cc	/^typedef void (*sighandler_t)(int sig);$/;"	t	file:
siginfo	rtl/tsan_interceptors.cc	/^  my_siginfo_t siginfo;$/;"	m	struct:__tsan::SignalDesc	file:
signal_ctx	rtl/tsan_rtl.h	/^  SignalContext *signal_ctx;$/;"	m	struct:__tsan::ThreadState
sigsetjmp	rtl/tsan_rtl_amd64.S	/^sigsetjmp:$/;"	l
singleton_thread	tests/rtl/tsan_mutex.cc	/^static void *singleton_thread(void *param) {$/;"	f	namespace:__tsan
siz	rtl/tsan_defs.h	/^  u64  siz;$/;"	m	struct:__tsan::MBlock
size	rtl/tsan_interface_ann.cc	/^  uptr size;$/;"	m	struct:__tsan::ExpectRace	file:
size	rtl/tsan_report.h	/^  int size;$/;"	m	struct:__tsan::ReportMop
size	rtl/tsan_rtl.h	/^  u64 ALWAYS_INLINE size() const { return 1ull << size_log(); }$/;"	f	class:__tsan::Shadow
size	tests/unit/tsan_clock_test.cc	/^  uptr size;$/;"	m	struct:__tsan::SimpleSyncClock	file:
size	tests/unit/tsan_clock_test.cc	/^  uptr size;$/;"	m	struct:__tsan::SimpleThreadClock	file:
size_	rtl/tsan_ignoreset.h	/^  uptr size_;$/;"	m	class:__tsan::IgnoreSet
size_	rtl/tsan_mutexset.h	/^  uptr size_;$/;"	m	class:__tsan::MutexSet
size_log	rtl/tsan_rtl.h	/^  u64 size_log() const { return (x_ >> (3 + kClkBits)) & 3; }$/;"	f	class:__tsan::Shadow
sleep	rtl/tsan_report.h	/^  ReportStack *sleep;$/;"	m	class:__tsan::ReportDesc
socksync	rtl/tsan_fd.cc	/^  FdSync socksync;$/;"	m	struct:__tsan::FdContext	file:
sp	rtl/tsan_rtl.h	/^  uptr sp;$/;"	m	struct:__tsan::JmpBuf
stack	rtl/tsan_report.h	/^  ReportStack *stack;$/;"	m	struct:__tsan::ReportLocation
stack	rtl/tsan_report.h	/^  ReportStack *stack;$/;"	m	struct:__tsan::ReportMop
stack	rtl/tsan_report.h	/^  ReportStack *stack;$/;"	m	struct:__tsan::ReportMutex
stack	rtl/tsan_report.h	/^  ReportStack *stack;$/;"	m	struct:__tsan::ReportThread
stack0	rtl/tsan_trace.h	/^  BufferedStackTrace stack0;  \/\/ Start stack for the trace.$/;"	m	struct:__tsan::TraceHeader
stacks	rtl/tsan_report.h	/^  Vector<ReportStack*> stacks;$/;"	m	class:__tsan::ReportDesc
stacks_	rtl/tsan_ignoreset.h	/^  u32 stacks_[kMaxSize];$/;"	m	class:__tsan::IgnoreSet
stat	rtl/tsan_rtl.h	/^  u64 stat[StatCnt];$/;"	m	struct:__tsan::Context
stat	rtl/tsan_rtl.h	/^  u64 stat[StatCnt];$/;"	m	struct:__tsan::ThreadState
stat_type_	rtl/tsan_mutex.h	/^  StatType stat_type_;$/;"	m	class:__tsan::Mutex
state_	rtl/tsan_mutex.h	/^  atomic_uintptr_t state_;$/;"	m	class:__tsan::Mutex
std	rtl/tsan_interceptors.cc	/^namespace std {$/;"	n	file:
std_suppressions	rtl/tsan_suppressions.cc	/^static const char *const std_suppressions =$/;"	v	file:
stderr	rtl/tsan_interceptors.cc	39;"	d	file:
stdout	rtl/tsan_interceptors.cc	38;"	d	file:
stk	rtl/tsan_defs.h	/^  u32  stk;$/;"	m	struct:__tsan::MBlock
stk_addr	rtl/tsan_rtl.h	/^  const uptr stk_addr;$/;"	m	struct:__tsan::ThreadState
stk_addr	rtl/tsan_rtl_thread.cc	/^  uptr stk_addr;$/;"	m	struct:__tsan::OnStartedArgs	file:
stk_size	rtl/tsan_rtl.h	/^  const uptr stk_size;$/;"	m	struct:__tsan::ThreadState
stk_size	rtl/tsan_rtl_thread.cc	/^  uptr stk_size;$/;"	m	struct:__tsan::OnStartedArgs	file:
stop_background_thread	rtl/tsan_rtl.h	/^  atomic_uint32_t stop_background_thread;$/;"	m	struct:__tsan::Context
stop_on_start	rtl/tsan_flags.h	/^  bool stop_on_start;$/;"	m	struct:__tsan::Flags
supp	rtl/tsan_rtl.h	/^  Suppression *supp;$/;"	m	struct:__tsan::FiredSuppression
suppress_equal_addresses	rtl/tsan_flags.h	/^  bool suppress_equal_addresses;$/;"	m	struct:__tsan::Flags
suppress_equal_stacks	rtl/tsan_flags.h	/^  bool suppress_equal_stacks;$/;"	m	struct:__tsan::Flags
suppressable	rtl/tsan_report.h	/^  bool suppressable;$/;"	m	struct:__tsan::ReportLocation
suppressable	rtl/tsan_report.h	/^  bool suppressable;$/;"	m	struct:__tsan::ReportStack
suppressions_inited	rtl/tsan_suppressions.cc	/^static bool suppressions_inited = false;$/;"	m	namespace:__tsan	file:
symbolize_cb	go/test.c	/^void symbolize_cb(void *ctx) {}$/;"	f
symbolize_cb	go/tsan_go.cc	/^static void (*symbolize_cb)(SymbolizeContext *ctx);$/;"	m	namespace:__tsan	file:
sync	rtl/tsan_fd.cc	/^  FdSync *sync;$/;"	m	struct:__tsan::FdDesc	file:
sync	rtl/tsan_rtl.h	/^  SyncClock sync;$/;"	m	class:__tsan::ThreadContext
sync_cache	rtl/tsan_rtl.h	/^  DenseSlabAllocCache sync_cache;$/;"	m	struct:__tsan::ThreadState
sync_ignore_set	rtl/tsan_rtl.h	/^  IgnoreSet sync_ignore_set;$/;"	m	struct:__tsan::ThreadState
syscall_access_range	rtl/tsan_interceptors.cc	/^static void syscall_access_range(uptr pc, uptr p, uptr s, bool write) {$/;"	f	file:
syscall_acquire	rtl/tsan_interceptors.cc	/^static void syscall_acquire(uptr pc, uptr addr) {$/;"	f	file:
syscall_fd_acquire	rtl/tsan_interceptors.cc	/^static USED void syscall_fd_acquire(uptr pc, int fd) {$/;"	f	file:
syscall_fd_close	rtl/tsan_interceptors.cc	/^static void syscall_fd_close(uptr pc, int fd) {$/;"	f	file:
syscall_fd_release	rtl/tsan_interceptors.cc	/^static USED void syscall_fd_release(uptr pc, int fd) {$/;"	f	file:
syscall_post_fork	rtl/tsan_interceptors.cc	/^static void syscall_post_fork(uptr pc, int pid) {$/;"	f	file:
syscall_pre_fork	rtl/tsan_interceptors.cc	/^static void syscall_pre_fork(uptr pc) {$/;"	f	file:
syscall_release	rtl/tsan_interceptors.cc	/^static void syscall_release(uptr pc, uptr addr) {$/;"	f	file:
tab	rtl/tsan_fd.cc	/^  atomic_uintptr_t tab[kTableSizeL1];$/;"	m	struct:__tsan::FdContext	file:
table	rtl/tsan_clock.h	/^    u32       table[kTableSize];$/;"	m	union:__tsan::ClockBlock::__anon3
tctx	rtl/tsan_rtl.h	/^  ThreadContext *tctx;$/;"	m	struct:__tsan::ThreadState
tctx	rtl/tsan_rtl_thread.cc	/^  ThreadContext *tctx;$/;"	m	struct:__tsan::ThreadLeak	file:
test_default_options	tests/unit/tsan_flags_test.cc	/^static const char *test_default_options;$/;"	m	namespace:__tsan	file:
thr	dd/dd_interceptors.cc	/^static __thread Thread *thr;$/;"	v	file:
thr	dd/dd_rtl.h	/^  Thread *thr;$/;"	m	struct:__dsan::Callback
thr	rtl/tsan_interceptors.cc	/^  ThreadState *thr;$/;"	m	struct:BlockingCall	file:
thr	rtl/tsan_interceptors.cc	/^  ThreadState *thr;$/;"	m	struct:CondMutexUnlockCtx	file:
thr	rtl/tsan_interceptors.cc	/^  ThreadState *thr;$/;"	m	struct:ScopedSyscall	file:
thr	rtl/tsan_interceptors.cc	/^  ThreadState *thr;$/;"	m	struct:TsanInterceptorContext	file:
thr	rtl/tsan_rtl.h	/^  ThreadState *thr;$/;"	m	class:__tsan::ThreadContext
thr	rtl/tsan_rtl_mutex.cc	/^  ThreadState *thr;$/;"	m	struct:__tsan::Callback	file:
thr	rtl/tsan_rtl_thread.cc	/^  ThreadState *thr;$/;"	m	struct:__tsan::OnCreatedArgs	file:
thr	rtl/tsan_rtl_thread.cc	/^  ThreadState *thr;$/;"	m	struct:__tsan::OnStartedArgs	file:
thr_	rtl/tsan_interceptors.cc	/^  ThreadState *const thr_;$/;"	m	class:ScopedInterceptor	file:
thr_	rtl/tsan_interface_ann.cc	/^  ThreadState *const thr_;$/;"	m	class:__tsan::ScopedAnnotation	file:
thr_	rtl/tsan_interface_atomic.cc	/^  ThreadState *thr_;$/;"	m	class:ScopedAtomic	file:
thr_	rtl/tsan_interface_java.cc	/^  ThreadState *thr_;$/;"	m	class:__tsan::ScopedJavaFunc	file:
thread	tests/rtl/tsan_test_util_linux.cc	/^  pthread_t thread;$/;"	m	struct:ScopedThread::Impl	file:
thread_alot_func	tests/rtl/tsan_thread.cc	/^static void *thread_alot_func(void *arg) {$/;"	f	file:
thread_finalize	rtl/tsan_interceptors.cc	/^static void thread_finalize(void *v) {$/;"	f	file:
thread_key	tests/rtl/tsan_posix.cc	/^  thread_key(pthread_key_t key, pthread_mutex_t *mtx, int val, int *cnt)$/;"	f	struct:thread_key
thread_key	tests/rtl/tsan_posix.cc	/^struct thread_key {$/;"	s	file:
thread_name	rtl/tsan_report.cc	/^const char *thread_name(char *buf, int tid) {$/;"	f	namespace:__tsan
thread_registry	rtl/tsan_rtl.h	/^  ThreadRegistry *thread_registry;$/;"	m	struct:__tsan::Context
thread_registry_placeholder	rtl/tsan_rtl.cc	/^static char thread_registry_placeholder[sizeof(ThreadRegistry)];$/;"	m	namespace:__tsan	file:
thread_secific_dtor	tests/rtl/tsan_posix.cc	/^static void thread_secific_dtor(void *v) {$/;"	f	file:
threads	rtl/tsan_report.h	/^  Vector<ReportThread*> threads;$/;"	m	class:__tsan::ReportDesc
tick	tests/unit/tsan_clock_test.cc	/^  void tick() {$/;"	f	struct:__tsan::SimpleThreadClock
tid	rtl/tsan_defs.h	/^  u16  tid;$/;"	m	struct:__tsan::MBlock
tid	rtl/tsan_interceptors.cc	/^  atomic_uintptr_t tid;$/;"	m	struct:ThreadParam	file:
tid	rtl/tsan_report.h	/^  int tid;$/;"	m	struct:__tsan::ReportLocation
tid	rtl/tsan_report.h	/^  int tid;$/;"	m	struct:__tsan::ReportMop
tid	rtl/tsan_rtl.h	/^  const int tid;$/;"	m	struct:__tsan::ThreadState
tid	rtl/tsan_rtl.h	/^  u64 tid() const {$/;"	f	class:__tsan::FastState
tid	tests/unit/tsan_clock_test.cc	/^  unsigned tid;$/;"	m	struct:__tsan::SimpleThreadClock	file:
timespec_diff	rtl/tsan_rtl_report.cc	/^struct timespec timespec_diff(struct timespec start, struct timespec end)$/;"	f	namespace:__tsan
tls_addr	rtl/tsan_rtl.h	/^  const uptr tls_addr;$/;"	m	struct:__tsan::ThreadState
tls_addr	rtl/tsan_rtl_thread.cc	/^  uptr tls_addr;$/;"	m	struct:__tsan::OnStartedArgs	file:
tls_size	rtl/tsan_rtl.h	/^  const uptr tls_size;$/;"	m	struct:__tsan::ThreadState
tls_size	rtl/tsan_rtl_thread.cc	/^  uptr tls_size;$/;"	m	struct:__tsan::OnStartedArgs	file:
to_atomic	rtl/tsan_interface_atomic.cc	/^static atomic_uint16_t *to_atomic(const volatile a16 *a) {$/;"	f	file:
to_atomic	rtl/tsan_interface_atomic.cc	/^static atomic_uint32_t *to_atomic(const volatile a32 *a) {$/;"	f	file:
to_atomic	rtl/tsan_interface_atomic.cc	/^static atomic_uint64_t *to_atomic(const volatile a64 *a) {$/;"	f	file:
to_atomic	rtl/tsan_interface_atomic.cc	/^static atomic_uint8_t *to_atomic(const volatile a8 *a) {$/;"	f	file:
to_mo	rtl/tsan_interface_atomic.cc	/^static memory_order to_mo(morder mo) {$/;"	f	file:
trace_buffer	rtl/tsan_stack_trace.h	/^  uptr *trace_buffer;  \/\/ Owned.$/;"	m	struct:__tsan::VarSizeStackTrace
typ	rtl/tsan_report.h	/^  ReportType typ;$/;"	m	class:__tsan::ReportDesc
typ_	rtl/tsan_vector.h	/^  const MBlockType typ_;$/;"	m	class:__tsan::Vector
type	rtl/tsan_report.h	/^  ReportLocationType type;$/;"	m	struct:__tsan::ReportLocation
type	rtl/tsan_rtl.h	/^  ReportType type;$/;"	m	struct:__tsan::FiredSuppression
type	tests/rtl/tsan_test_util_linux.cc	/^  Type type;$/;"	m	struct:Event	file:
type_	rtl/tsan_mutex.h	/^  MutexType type_;$/;"	m	class:__tsan::Mutex
type_	tests/rtl/tsan_test_util.h	/^  const Type type_;$/;"	m	class:Mutex
ucontext_t	rtl/tsan_interceptors.cc	/^struct ucontext_t {$/;"	s	file:
uid	rtl/tsan_sync.h	/^  u64 uid;  \/\/ Globally unique id.$/;"	m	struct:__tsan::SyncVar
uint16_t	rtl/tsan_interface.cc	/^typedef u16 uint16_t;$/;"	t	file:
uint32_t	rtl/tsan_interface.cc	/^typedef u32 uint32_t;$/;"	t	file:
uint64_t	rtl/tsan_interface.cc	/^typedef u64 uint64_t;$/;"	t	file:
ulong_t	rtl/tsan_md5.cc	/^typedef unsigned long ulong_t;  \/\/ NOLINT$/;"	t	namespace:__tsan	file:
unique_id	rtl/tsan_rtl.h	/^  const int unique_id;$/;"	m	struct:__tsan::ThreadState
unique_tids	rtl/tsan_report.h	/^  Vector<int> unique_tids;$/;"	m	class:__tsan::ReportDesc
unreachable	rtl/tsan_interceptors.cc	/^static void unreachable() {$/;"	f	namespace:__tsan
unref	rtl/tsan_fd.cc	/^static void unref(ThreadState *thr, uptr pc, FdSync *s) {$/;"	f	namespace:__tsan
user_alloc	rtl/tsan_mman.cc	/^void *user_alloc(ThreadState *thr, uptr pc, uptr sz, uptr align, bool signal) {$/;"	f	namespace:__tsan
user_alloc_usable_size	rtl/tsan_mman.cc	/^uptr user_alloc_usable_size(const void *p) {$/;"	f	namespace:__tsan
user_free	rtl/tsan_mman.cc	/^void user_free(ThreadState *thr, uptr pc, void *p, bool signal) {$/;"	f	namespace:__tsan
user_realloc	rtl/tsan_mman.cc	/^void *user_realloc(ThreadState *thr, uptr pc, void *p, uptr sz) {$/;"	f	namespace:__tsan
val	tests/rtl/tsan_posix.cc	/^  int val;$/;"	m	struct:thread_key	file:
verify	tests/unit/tsan_clock_test.cc	/^  bool verify(const SyncClock *other) const {$/;"	f	struct:__tsan::SimpleSyncClock
verify	tests/unit/tsan_clock_test.cc	/^  bool verify(const ThreadClock *other) const {$/;"	f	struct:__tsan::SimpleThreadClock
write	rtl/tsan_mutexset.h	/^    bool write;$/;"	m	struct:__tsan::MutexSet::Desc
write	rtl/tsan_report.h	/^  bool write;$/;"	m	struct:__tsan::ReportMop
write	rtl/tsan_report.h	/^  bool write;$/;"	m	struct:__tsan::ReportMopMutex
write_mutex_thread	tests/unit/tsan_mutex_test.cc	/^static void *write_mutex_thread(void *param) {$/;"	f	namespace:__tsan
x_	rtl/tsan_rtl.h	/^  u64 x_;$/;"	m	class:__tsan::FastState
~BlockingCall	rtl/tsan_interceptors.cc	/^  ~BlockingCall() {$/;"	f	struct:BlockingCall
~DenseSlabAlloc	rtl/tsan_dense_alloc.h	/^  ~DenseSlabAlloc() {$/;"	f	class:__tsan::DenseSlabAlloc
~MemLoc	tests/rtl/tsan_test_util_linux.cc	/^MemLoc::~MemLoc() {$/;"	f	class:MemLoc
~Mutex	benchmarks/vts_many_threads_bench.cc	/^  ~Mutex() { pthread_mutex_destroy(&m_); }$/;"	f	class:Mutex
~Mutex	rtl/tsan_mutex.cc	/^Mutex::~Mutex() {$/;"	f	class:__tsan::Mutex
~Mutex	tests/rtl/tsan_test_util_linux.cc	/^Mutex::~Mutex() {$/;"	f	class:Mutex
~ReportDesc	rtl/tsan_report.cc	/^ReportDesc::~ReportDesc() {$/;"	f	class:__tsan::ReportDesc
~ScopedAnnotation	rtl/tsan_interface_ann.cc	/^  ~ScopedAnnotation() {$/;"	f	class:__tsan::ScopedAnnotation
~ScopedAtomic	rtl/tsan_interface_atomic.cc	/^  ~ScopedAtomic() {$/;"	f	class:ScopedAtomic
~ScopedIgnoreInterceptors	rtl/tsan_rtl.h	/^  ~ScopedIgnoreInterceptors() {$/;"	f	struct:__tsan::ScopedIgnoreInterceptors
~ScopedInterceptor	rtl/tsan_interceptors.cc	/^ScopedInterceptor::~ScopedInterceptor() {$/;"	f	class:ScopedInterceptor
~ScopedJavaFunc	rtl/tsan_interface_java.cc	/^  ~ScopedJavaFunc() {$/;"	f	class:__tsan::ScopedJavaFunc
~ScopedReport	rtl/tsan_rtl_report.cc	/^ScopedReport::~ScopedReport() {$/;"	f	class:__tsan::ScopedReport
~ScopedSyscall	rtl/tsan_interceptors.cc	/^  ~ScopedSyscall() {$/;"	f	struct:ScopedSyscall
~ScopedThread	tests/rtl/tsan_test_util_linux.cc	/^ScopedThread::~ScopedThread() {$/;"	f	class:ScopedThread
~SyncClock	rtl/tsan_clock.cc	/^SyncClock::~SyncClock() {$/;"	f	class:__tsan::SyncClock
~ThreadContext	rtl/tsan_rtl_thread.cc	/^ThreadContext::~ThreadContext() {$/;"	f	class:__tsan::ThreadContext
~VarSizeStackTrace	rtl/tsan_stack_trace.cc	/^VarSizeStackTrace::~VarSizeStackTrace() {$/;"	f	class:__tsan::VarSizeStackTrace
~Vector	rtl/tsan_vector.h	/^  ~Vector() {$/;"	f	class:__tsan::Vector
